<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta name="generator" content="Hugo 0.155.3" />
  <meta charset="utf-8">
  <title>python基础 · helloj</title><meta name="referrer" content="no-referrer" />
<meta data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="[TOC]
基础 继承： “定义子类时，必须在括号内指定父类的名称。” class ElectricCar(Car):
“类名应采用驼峰命名法 ，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。”
" />


<link rel="canonical" href="https://justinbetter.github.io/2019/08/08/python%E5%9F%BA%E7%A1%80/" />

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
<link rel="stylesheet" href="https://justinbetter.github.io/css/den.css">







</head>
<body>
  
  <div class="header-container gradient">
  <div class="container">
  <nav class="header-nav navbar navbar-expand-md navbar-dark light-dark">
    <div class="header-logo navbar-brand">
      
        <a class="float-left" href="https://justinbetter.github.io/">
      
        
        
          helloj
         
      </a>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="nav-menu collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav">
        
          <li class="nav-item">
            
              
                <a class="nav-link" href="https://justinbetter.github.io/category/notes/">Notes</a>
              
            
          </li>
        
          <li class="nav-item">
            
              
                <a class="nav-link" href="https://justinbetter.github.io/category/demos/">Demos</a>
              
            
          </li>
        
          <li class="nav-item">
            
              <a class="nav-link" href="https://justinbetter.github.io/about/">About</a>
            
          </li>
        
        
      </ul>
    </div>
  </nav>
</div>

<div class="container header-wrapper">
  <div class="row">
    <div class="col-lg-12">
      <div class="header-content">
        <h1 class="header-title">python基础</h1>
        <p class="header-date">
        Thu 08 August 2019
        <div class="header-underline"></div>
        
        

      </div>
    </div>
  </div>
</div>

  </div>
  <main>
<div class="container content">
  <article>
  <p>[TOC]</p>
<h2 id="基础">基础</h2>
<p>继承： “定义子类时，必须在括号内指定父类的名称。”
class ElectricCar(Car):</p>
<p>“类名应采用驼峰命名法 ，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。”</p>
<h3 id="输出输入">输出输入</h3>
<ul>
<li>print()</li>
<li>input()</li>
</ul>
<p>###数据类型</p>
<ul>
<li>整数</li>
<li>浮点数</li>
<li>字符串</li>
<li>布尔值</li>
<li>空值 None</li>
<li>变量</li>
<li>常量</li>
</ul>
<p>###字符编码</p>
<ul>
<li>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间</li>
<li>ord() 获取整数表示</li>
<li>chr() 编码转化为字符</li>
<li>encode(&lsquo;ascii&rsquo;) str编码为指定的byte作为网络传输</li>
<li>decode(&lsquo;utf-8&rsquo;)  byte变为str读取网络字节流</li>
<li>len()</li>
<li>格式化 %d %f %s %x</li>
</ul>
<h3 id="list-和tuple">list 和tuple</h3>
<ul>
<li>
<p>list  [1,3,2]</p>
<ul>
<li>len()</li>
<li>append()</li>
<li>insert()</li>
<li>pop()</li>
</ul>
</li>
<li>
<p>tuple 另一种有序列表，一经初始化不能修改</p>
<ul>
<li>(1,)</li>
<li>和list的区别就是不可变</li>
</ul>
</li>
</ul>
<p>###条件判断</p>
<ul>
<li>if : &hellip;elif:&hellip; else:&hellip;.
###循环</li>
<li>for..in..</li>
<li>for x in &hellip;循环就是把每个元素代入变量x，然后执行缩进块的语句。</li>
<li>range()</li>
<li>while x&gt;0:&hellip;</li>
<li>break 退出循环</li>
<li>continue  跳过</li>
</ul>
<h3 id="dict和set">dict和set</h3>
<ul>
<li>
<p>dict  {&lsquo;Michael&rsquo;: 95, &lsquo;Bob&rsquo;: 75, &lsquo;Tracy&rsquo;: 85}</p>
<ul>
<li>类似map，键值对</li>
<li>判断key是否存在
- ’a‘ in dict 通过in
- d.get(&lsquo;Thomas&rsquo;, -1)</li>
<li>pop(key) 删除指定键值对</li>
</ul>
</li>
<li>
<p>set 只包含key的集合{1,2，3}</p>
<ul>
<li>add()</li>
<li>remove()</li>
<li>两个set 可以做&amp; |</li>
</ul>
</li>
</ul>
<p>###函数</p>
<ul>
<li>
<p>abs()</p>
</li>
<li>
<p>max()</p>
</li>
<li>
<p>数据类型转换</p>
<ul>
<li>int(&lsquo;123&rsquo;)</li>
<li>float()</li>
<li>str()</li>
<li>bool()</li>
</ul>
</li>
<li>
<p>定义函数 def my_function(x):&hellip;</p>
</li>
<li>
<p>导入函数 from demo1 import my_function</p>
</li>
<li>
<p>pass 什么都不做</p>
</li>
<li>
<p>isinstance(x,(int, float))</p>
</li>
<li>
<p>参数</p>
<ul>
<li>位置参数</li>
<li>默认参数 def power(x, n=2):..</li>
<li>可变参数 def calc(*number):&hellip;return sum 在函数调用时自动组装为一个tuple</li>
<li>关键字参数 def person(name,age,**kw):&hellip;传入任意dict</li>
<li>命名关键字参数 def person(name,age,*,city,job):&hellip; 调用时必须写key参数名</li>
</ul>
</li>
<li>
<p>递归函数</p>
<ul>
<li>
<p>尾递归优化（没做优化，也没啥用，依然可能栈溢出）</p>
<pre><code> def fact(n):
   return fact_iter(n,1)

 def fact_iter(num,product):
   if num == 1:
       retutn 1
   return fact_iter(num-1,num*product)
</code></pre>
</li>
</ul>
</li>
</ul>
<p>###特性</p>
<ul>
<li>
<p>切片</p>
<ul>
<li>L[0:10] 取0-9，0可以省略，指取10个</li>
<li>L[-10:] 取倒数10个元素</li>
<li>L[::5] 所有数每5个取一个</li>
<li>list、tuple、str 都可以用切片操作</li>
</ul>
</li>
<li>
<p>迭代</p>
<ul>
<li>list、tuple 直接for&hellip;in..</li>
<li>dict
<ul>
<li>for key in d</li>
<li>for value in d.values()</li>
<li>for k,v in d.items()</li>
</ul>
</li>
<li>字符串 for ch in &lsquo;ABC&rsquo;:</li>
<li>list 使用下标循环 for i,value in enumerate([&lsquo;A&rsquo;,&lsquo;B&rsquo;,&lsquo;C&rsquo;]):</li>
</ul>
</li>
<li>
<p>列表生成式</p>
<ul>
<li>创建list的生成式</li>
<li>[x*x for x in range(1,11) if x % 2 ==0]</li>
<li>还可以两层循环 [m + n for m in &lsquo;ABC for n in &lsquo;XYZ&rsquo;]</li>
<li>也可以使用两个变量 [k +&rsquo;=&rsquo;+v for k,v in d.items()]</li>
</ul>
</li>
<li>
<p>生成器</p>
<ul>
<li>generator 一边循环一边计算的机制</li>
<li>创建方法：
<ul>
<li>
<p>g = (x * x for x in range(10)) 把一个列表生成式的[]改成()</p>
</li>
<li>
<p>next（g) 获得下一个返回值</p>
</li>
<li>
<p>for n in g:&hellip; 可以迭代循环generator</p>
</li>
<li>
<p>推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现</p>
<pre><code>  def fib(max) :
      n,a,b = 0,0,1
      while n&lt; max:
          yield b
          a,b = b,a+b
          n = n + 1
      return 'done'
</code></pre>
</li>
<li>
<p>yield 使函数变成一个generator</p>
</li>
<li>
<p>for 循环调用generator时想拿到返回值必须捕获StopIteration</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>迭代器</p>
<ul>
<li>Iterable 可直接作用for循环的对象 list、tuple、dict、set、str、generator</li>
<li>Iterator 迭代器，可以被next()函数调用并不断返回下一个值的对象</li>
<li>isinstance</li>
<li>from collections import Iterator</li>
</ul>
</li>
</ul>
<h3 id="函数式编程">函数式编程</h3>
<ul>
<li>
<p>高阶函数 一个函数可以接受另一个函数作为参数</p>
<pre><code>  def add(a,b,f):
      return  f(a) +ｆ（ｂ）
</code></pre>
<ul>
<li>
<p><strong>map()</strong> 接收函数和Iterable，返回Iterator</p>
<pre><code>   list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
</code></pre>
</li>
<li>
<p>**reduce()**接受函数和序列，函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</p>
<pre><code>  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
</li>
<li>
<p><strong>filter()</strong> 过滤序列</p>
<pre><code>  list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
</code></pre>
</li>
<li>
<p><strong>sorted()</strong> 可以对list排序，可以接收一个key函数来实现自定义的排序</p>
<pre><code>   sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
</code></pre>
</li>
</ul>
</li>
<li>
<p>返回函数</p>
<ul>
<li>
<p>高阶函数除了可以接收函数作为参数还可以将函数作为结果值返回</p>
<pre><code>  def lazy_sum(*args):
      def sum():
          ax = 0
          for n in args:
              ax = ax + n
          return ax
      return sum
  f #返回函数
  f() #调用函数
</code></pre>
</li>
<li>
<p>返回函数中不要引用任何可能会变化的变量。</p>
</li>
</ul>
</li>
<li>
<p>匿名函数 lambda x ： x*x</p>
</li>
<li>
<p>装饰器 decorator</p>
<ul>
<li>
<p>函数也是一个对象 也有属性 f.<em>name</em>  拿到f函数的名字</p>
</li>
<li>
<p>decorator就是一个返回函数的高阶函数</p>
<pre><code>  import functools

  def log(func):
      #把原始函数的__name__等属性复制到wrapper()函数
      @functools.wrap(func) 

      def wrapper(*args, **kw):
          print('call %s():' % func.__name__)
          return func(*args, **kw)
      return wrapper

  @log
  def now():
          print('2015-3-25')

  把@log放到now()函数的定义处，相当于执行了语句：now = log(now)
</code></pre>
</li>
</ul>
</li>
<li>
<p>偏函数</p>
<pre><code>      import functools
      int2 = functools.partial(int ,base = 2)
      int2('1010101')  #85
</code></pre>
</li>
</ul>
<p>###模块</p>
<pre><code>    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    
    ' a test module '
    
    __author__ = 'Michael Liao'
    
    import sys
    
    def test():
        args = sys.argv
        if len(args)==1:
                print('Hello, world!')
        elif len(args)==2:
            print('Hello, %s!' % args[1])
        else:
            print('Too many arguments!')
    
    if __name__=='__main__':
        test()
</code></pre>
<ul>
<li>
<p>import sys 导入模块</p>
</li>
<li>
<p>sys模块有一个argv变量，用list存储了命令行的所有参数</p>
</li>
<li>
<p>命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，一般用于测试</p>
</li>
<li>
<p>作用域</p>
<ul>
<li>正常函数变量名可以直接引用</li>
<li>_xxx_特殊变量名</li>
<li>_xxx和__xxx非公开的函数private</li>
</ul>
</li>
<li>
<p>安装模块 pip install Pillow</p>
</li>
<li>
<p>模块搜索路径 存放在sys模块的path变量中</p>
<ul>
<li>一是直接修改sys.path，添加要搜索的目录： sys.path.append(&rsquo;/Users/michael/my_py_scripts&rsquo;)</li>
<li>第二种方法是设置环境变量PYTHONPATH</li>
</ul>
</li>
</ul>
<h3 id="面向对象编程">面向对象编程</h3>
<pre><code> class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))
</code></pre>
<ul>
<li>
<p>创建实例直接 bart = Student()</p>
</li>
<li>
<p>__name 双下划线 变成了私有变量，实质是Python解释器对外改成了_Student__name</p>
</li>
<li>
<p>继承</p>
<pre><code>   class Dog（Animal）:
      def run(self):
          print(Dog is running...)
      def eat(self):
          print(Dog is eating...)
</code></pre>
</li>
<li>
<p>获取对象信息</p>
<ul>
<li>type()</li>
<li>isinstance(&lsquo;a&rsquo;,str)</li>
<li>dir() 获得对象的所有属性和方法</li>
<li>操作状态 getattr() 、setattr()、hasattr()</li>
</ul>
</li>
<li>
<p>类属性 相当于成员变量</p>
</li>
</ul>
<p>###面向对象高级编程</p>
<ul>
<li>
<p>限制实例的变量</p>
<pre><code>  class Student(object):
      __slot__ = ('name','age') # 用元组定义只允许绑定的属性
</code></pre>
</li>
<li>
<p>为了检查参数使用</p>
<pre><code>  class Student(Object):

      @property
      def score(self):
          return self._score

      @score.setter
      def score(self,value):
          if not isinstance(value,int):
              raise ValueError('must be integer')
          if value &lt; 0 or value &gt; 100:
              raise ValueError('more than..')
          self._score = value                
</code></pre>
<ul>
<li>@property      把getter方法变成了属性</li>
<li>@score.setter        @property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值</li>
<li>只定义getter方法@property，不定义setter方法就是一个只读属性：</li>
</ul>
</li>
<li>
<p>多重继承</p>
<ul>
<li>class Dog（Mammal，Runnable）</li>
<li>让某个类除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn</li>
</ul>
</li>
<li>
<p>定制类</p>
<pre><code>  __str__    #print 返回自定义字符串，直接敲变量本质调用__repr__
  __iter__ #返回一个迭代对象 
  __getitem__ # 像list一样可以按下标访问数列的任意一项
  __getattr__  #在没有找到属性的情况下，才调用__getattr__
  __call__     #可以对实例直接调用，callable()判断是否可调用
</code></pre>
</li>
<li>
<p>枚举类</p>
<pre><code>  from enum import Enum
  Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

  for name,member in Month.__member__.items():
      print(name,'==&gt;',member,',',member.value)

  #value属性则是自动赋给成员的int常量，默认从1开始计数。
</code></pre>
</li>
</ul>
<hr>
<pre><code>    from enum import Enum, unique
    
    @unique                  #检查没有重复值
    class Weekday(Enum):    #从Enum派生出自定义类
        Sun = 0 # Sun的value被设定为0
        Mon = 1
        Tue = 2
        Wed = 3
        Thu = 4
        Fri = 5
        Sat = 6
</code></pre>
<ul>
<li>元类 metaclass
<ul>
<li>
<p>type() 既可以返回对象的类型，又可以创建出新的类型</p>
<pre><code>  def fn(self,name='world'):
      print('Hello,%s!'%name)

  Hello = type('Hello',(object,),dict(hello=fn)) # 创建Hello.class
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="错误处理">错误处理</h3>
<pre><code>	try:
    	10 / 0
	except ZeroDivisionError:
    	raise ValueError('input error!')
</code></pre>
<ul>
<li>
<p>断言</p>
<pre><code>  def foo(s):
      n = int(s)
      assert n != 0, 'n is zero!'
      return 10 / n

  def main():
      foo('0')	
</code></pre>
<ul>
<li>
<p>用-O参数来关闭assert:</p>
<pre><code>  python3 -O err.py	
</code></pre>
</li>
</ul>
</li>
<li>
<p>logging</p>
<pre><code>  import logging
  logging.basicConfig(level=logging.INFO)

  s = '0'
  n = int(s)
  logging.info('n = %d' % n)
  print(10 / n)
</code></pre>
</li>
</ul>
<p>###读写文件</p>
<ul>
<li>
<p>读</p>
<pre><code>  with open('path','rb') as f :
  	print(f.read())

  #二进制 编码 编码错误
   f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')
</code></pre>
</li>
<li>
<p>写</p>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>	with open('/Users/michael/test.txt', 'w') as f:
	    f.write('Hello, world!')		
</code></pre>
<ul>
<li>
<p>IO流</p>
<ul>
<li>StringIO</li>
<li>BytesIO</li>
<li></li>
</ul>
</li>
<li>
<p>参考：
<a href="http://www.liaoxuefeng.com/#%23">http://www.liaoxuefeng.com/##</a>基础</p>
</li>
</ul>
<h3 id="输出输入-1">输出输入</h3>
<ul>
<li>print()</li>
<li>input()</li>
</ul>
<p>###数据类型</p>
<ul>
<li>整数</li>
<li>浮点数</li>
<li>字符串</li>
<li>布尔值</li>
<li>空值 None</li>
<li>变量</li>
<li>常量</li>
</ul>
<p>###字符编码</p>
<ul>
<li>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间</li>
<li>ord() 获取整数表示</li>
<li>chr() 编码转化为字符</li>
<li>encode(&lsquo;ascii&rsquo;) str编码为指定的byte作为网络传输</li>
<li>decode(&lsquo;utf-8&rsquo;)  byte变为str读取网络字节流</li>
<li>len()</li>
<li>格式化 %d %f %s %x</li>
</ul>
<h3 id="list-和tuple-1">list 和tuple</h3>
<ul>
<li>
<p>list  [1,3,2]</p>
<ul>
<li>len()</li>
<li>append()</li>
<li>insert()</li>
<li>pop()</li>
</ul>
</li>
<li>
<p>tuple 另一种有序列表，一经初始化不能修改</p>
<ul>
<li>(1,)</li>
<li>和list的区别就是不可变</li>
</ul>
</li>
</ul>
<p>###条件判断</p>
<ul>
<li>if : &hellip;elif:&hellip; else:&hellip;.
###循环</li>
<li>for..in..</li>
<li>for x in &hellip;循环就是把每个元素代入变量x，然后执行缩进块的语句。</li>
<li>range()</li>
<li>while x&gt;0:&hellip;</li>
<li>break 退出循环</li>
<li>continue  跳过</li>
</ul>
<h3 id="dict和set-1">dict和set</h3>
<ul>
<li>
<p>dict  {&lsquo;Michael&rsquo;: 95, &lsquo;Bob&rsquo;: 75, &lsquo;Tracy&rsquo;: 85}</p>
<ul>
<li>类似map，键值对</li>
<li>判断key是否存在
- ’a‘ in dict 通过in
- d.get(&lsquo;Thomas&rsquo;, -1)</li>
<li>pop(key) 删除指定键值对</li>
</ul>
</li>
<li>
<p>set 只包含key的集合{1,2，3}</p>
<ul>
<li>add()</li>
<li>remove()</li>
<li>两个set 可以做&amp; |</li>
</ul>
</li>
</ul>
<p>###函数</p>
<ul>
<li>
<p>abs()</p>
</li>
<li>
<p>max()</p>
</li>
<li>
<p>数据类型转换</p>
<ul>
<li>int(&lsquo;123&rsquo;)</li>
<li>float()</li>
<li>str()</li>
<li>bool()</li>
</ul>
</li>
<li>
<p>定义函数 def my_function(x):&hellip;</p>
</li>
<li>
<p>导入函数 from demo1 import my_function</p>
</li>
<li>
<p>pass 什么都不做</p>
</li>
<li>
<p>isinstance(x,(int, float))</p>
</li>
<li>
<p>参数</p>
<ul>
<li>位置参数</li>
<li>默认参数 def power(x, n=2):..</li>
<li>可变参数 def calc(*number):&hellip;return sum 在函数调用时自动组装为一个tuple</li>
<li>关键字参数 def person(name,age,**kw):&hellip;传入任意dict</li>
<li>命名关键字参数 def person(name,age,*,city,job):&hellip; 调用时必须写key参数名</li>
</ul>
</li>
<li>
<p>递归函数</p>
<ul>
<li>
<p>尾递归优化（没做优化，也没啥用，依然可能栈溢出）</p>
<pre><code> def fact(n):
   return fact_iter(n,1)

 def fact_iter(num,product):
   if num == 1:
       retutn 1
   return fact_iter(num-1,num*product)
</code></pre>
</li>
</ul>
</li>
</ul>
<p>###特性</p>
<ul>
<li>
<p>切片</p>
<ul>
<li>L[0:10] 取0-9，0可以省略，指取10个</li>
<li>L[-10:] 取倒数10个元素</li>
<li>L[::5] 所有数每5个取一个</li>
<li>list、tuple、str 都可以用切片操作</li>
</ul>
</li>
<li>
<p>迭代</p>
<ul>
<li>list、tuple 直接for&hellip;in..</li>
<li>dict
<ul>
<li>for key in d</li>
<li>for value in d.values()</li>
<li>for k,v in d.items()</li>
</ul>
</li>
<li>字符串 for ch in &lsquo;ABC&rsquo;:</li>
<li>list 使用下标循环 for i,value in enumerate([&lsquo;A&rsquo;,&lsquo;B&rsquo;,&lsquo;C&rsquo;]):</li>
</ul>
</li>
<li>
<p>列表生成式</p>
<ul>
<li>创建list的生成式</li>
<li>[x*x for x in range(1,11) if x % 2 ==0]</li>
<li>还可以两层循环 [m + n for m in &lsquo;ABC for n in &lsquo;XYZ&rsquo;]</li>
<li>也可以使用两个变量 [k +&rsquo;=&rsquo;+v for k,v in d.items()]</li>
</ul>
</li>
<li>
<p>生成器</p>
<ul>
<li>generator 一边循环一边计算的机制</li>
<li>创建方法：
<ul>
<li>
<p>g = (x * x for x in range(10)) 把一个列表生成式的[]改成()</p>
</li>
<li>
<p>next（g) 获得下一个返回值</p>
</li>
<li>
<p>for n in g:&hellip; 可以迭代循环generator</p>
</li>
<li>
<p>推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现</p>
<pre><code>  def fib(max) :
      n,a,b = 0,0,1
      while n&lt; max:
          yield b
          a,b = b,a+b
          n = n + 1
      return 'done'
</code></pre>
</li>
<li>
<p>yield 使函数变成一个generator</p>
</li>
<li>
<p>for 循环调用generator时想拿到返回值必须捕获StopIteration</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>迭代器</p>
<ul>
<li>Iterable 可直接作用for循环的对象 list、tuple、dict、set、str、generator</li>
<li>Iterator 迭代器，可以被next()函数调用并不断返回下一个值的对象</li>
<li>isinstance</li>
<li>from collections import Iterator</li>
</ul>
</li>
</ul>
<h3 id="函数式编程-1">函数式编程</h3>
<ul>
<li>
<p>高阶函数 一个函数可以接受另一个函数作为参数</p>
<pre><code>  def add(a,b,f):
      return  f(a) +ｆ（ｂ）
</code></pre>
<ul>
<li>
<p><strong>map()</strong> 接收函数和Iterable，返回Iterator</p>
<pre><code>   list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
</code></pre>
</li>
<li>
<p>**reduce()**接受函数和序列，函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</p>
<pre><code>  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
</li>
<li>
<p><strong>filter()</strong> 过滤序列</p>
<pre><code>  list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
</code></pre>
</li>
<li>
<p><strong>sorted()</strong> 可以对list排序，可以接收一个key函数来实现自定义的排序</p>
<pre><code>   sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
</code></pre>
</li>
</ul>
</li>
<li>
<p>返回函数</p>
<ul>
<li>
<p>高阶函数除了可以接收函数作为参数还可以将函数作为结果值返回</p>
<pre><code>  def lazy_sum(*args):
      def sum():
          ax = 0
          for n in args:
              ax = ax + n
          return ax
      return sum
  f #返回函数
  f() #调用函数
</code></pre>
</li>
<li>
<p>返回函数中不要引用任何可能会变化的变量。</p>
</li>
</ul>
</li>
<li>
<p>匿名函数 lambda x ： x*x</p>
</li>
<li>
<p>装饰器 decorator</p>
<ul>
<li>
<p>函数也是一个对象 也有属性 f.<em>name</em>  拿到f函数的名字</p>
</li>
<li>
<p>decorator就是一个返回函数的高阶函数</p>
<pre><code>  import functools

  def log(func):
      #把原始函数的__name__等属性复制到wrapper()函数
      @functools.wrap(func) 

      def wrapper(*args, **kw):
          print('call %s():' % func.__name__)
          return func(*args, **kw)
      return wrapper

  @log
  def now():
          print('2015-3-25')

  把@log放到now()函数的定义处，相当于执行了语句：now = log(now)
</code></pre>
</li>
</ul>
</li>
<li>
<p>偏函数</p>
<pre><code>      import functools
      int2 = functools.partial(int ,base = 2)
      int2('1010101')  #85
</code></pre>
</li>
</ul>
<p>###模块</p>
<pre><code>    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    
    ' a test module '
    
    __author__ = 'Michael Liao'
    
    import sys
    
    def test():
        args = sys.argv
        if len(args)==1:
                print('Hello, world!')
        elif len(args)==2:
            print('Hello, %s!' % args[1])
        else:
            print('Too many arguments!')
    
    if __name__=='__main__':
        test()
</code></pre>
<ul>
<li>
<p>import sys 导入模块</p>
</li>
<li>
<p>sys模块有一个argv变量，用list存储了命令行的所有参数</p>
</li>
<li>
<p>命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，一般用于测试</p>
</li>
<li>
<p>作用域</p>
<ul>
<li>正常函数变量名可以直接引用</li>
<li>_xxx_特殊变量名</li>
<li>_xxx和__xxx非公开的函数private</li>
</ul>
</li>
<li>
<p>安装模块 pip install Pillow</p>
</li>
<li>
<p>模块搜索路径 存放在sys模块的path变量中</p>
<ul>
<li>一是直接修改sys.path，添加要搜索的目录： sys.path.append(&rsquo;/Users/michael/my_py_scripts&rsquo;)</li>
<li>第二种方法是设置环境变量PYTHONPATH</li>
</ul>
</li>
</ul>
<h3 id="面向对象编程-1">面向对象编程</h3>
<pre><code> class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))
</code></pre>
<ul>
<li>
<p>创建实例直接 bart = Student()</p>
</li>
<li>
<p>__name 双下划线 变成了私有变量，实质是Python解释器对外改成了_Student__name</p>
</li>
<li>
<p>继承</p>
<pre><code>   class Dog（Animal）:
      def run(self):
          print(Dog is running...)
      def eat(self):
          print(Dog is eating...)
</code></pre>
</li>
<li>
<p>获取对象信息</p>
<ul>
<li>type()</li>
<li>isinstance(&lsquo;a&rsquo;,str)</li>
<li>dir() 获得对象的所有属性和方法</li>
<li>操作状态 getattr() 、setattr()、hasattr()</li>
</ul>
</li>
<li>
<p>类属性 相当于成员变量</p>
</li>
</ul>
<p>###面向对象高级编程</p>
<ul>
<li>
<p>限制实例的变量</p>
<pre><code>  class Student(object):
      __slot__ = ('name','age') # 用元组定义只允许绑定的属性
</code></pre>
</li>
<li>
<p>为了检查参数使用</p>
<pre><code>  class Student(Object):

      @property
      def score(self):
          return self._score

      @score.setter
      def score(self,value):
          if not isinstance(value,int):
              raise ValueError('must be integer')
          if value &lt; 0 or value &gt; 100:
              raise ValueError('more than..')
          self._score = value                
</code></pre>
<ul>
<li>@property      把getter方法变成了属性</li>
<li>@score.setter        @property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值</li>
<li>只定义getter方法@property，不定义setter方法就是一个只读属性：</li>
</ul>
</li>
<li>
<p>多重继承</p>
<ul>
<li>class Dog（Mammal，Runnable）</li>
<li>让某个类除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn</li>
</ul>
</li>
<li>
<p>定制类</p>
<pre><code>  __str__    #print 返回自定义字符串，直接敲变量本质调用__repr__
  __iter__ #返回一个迭代对象 
  __getitem__ # 像list一样可以按下标访问数列的任意一项
  __getattr__  #在没有找到属性的情况下，才调用__getattr__
  __call__     #可以对实例直接调用，callable()判断是否可调用
</code></pre>
</li>
<li>
<p>枚举类</p>
<pre><code>  from enum import Enum
  Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

  for name,member in Month.__member__.items():
      print(name,'==&gt;',member,',',member.value)

  #value属性则是自动赋给成员的int常量，默认从1开始计数。
</code></pre>
</li>
</ul>
<hr>
<pre><code>    from enum import Enum, unique
    
    @unique                  #检查没有重复值
    class Weekday(Enum):    #从Enum派生出自定义类
        Sun = 0 # Sun的value被设定为0
        Mon = 1
        Tue = 2
        Wed = 3
        Thu = 4
        Fri = 5
        Sat = 6
</code></pre>
<ul>
<li>元类 metaclass
<ul>
<li>
<p>type() 既可以返回对象的类型，又可以创建出新的类型</p>
<pre><code>  def fn(self,name='world'):
      print('Hello,%s!'%name)

  Hello = type('Hello',(object,),dict(hello=fn)) # 创建Hello.class
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="错误处理-1">错误处理</h3>
<pre><code>	try:
    	10 / 0
	except ZeroDivisionError:
    	raise ValueError('input error!')
</code></pre>
<ul>
<li>
<p>断言</p>
<pre><code>  def foo(s):
      n = int(s)
      assert n != 0, 'n is zero!'
      return 10 / n

  def main():
      foo('0')	
</code></pre>
<ul>
<li>
<p>用-O参数来关闭assert:</p>
<pre><code>  python3 -O err.py	
</code></pre>
</li>
</ul>
</li>
<li>
<p>logging</p>
<pre><code>  import logging
  logging.basicConfig(level=logging.INFO)

  s = '0'
  n = int(s)
  logging.info('n = %d' % n)
  print(10 / n)
</code></pre>
</li>
</ul>
<p>###读写文件</p>
<ul>
<li>
<p>读</p>
<pre><code>  with open('path','rb') as f :
  	print(f.read())

  #二进制 编码 编码错误
   f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')
</code></pre>
</li>
<li>
<p>写</p>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>	with open('/Users/michael/test.txt', 'w') as f:
	    f.write('Hello, world!')		
</code></pre>
<ul>
<li>
<p>IO流</p>
<ul>
<li>StringIO</li>
<li>BytesIO</li>
<li></li>
</ul>
</li>
<li>
<p>参考：
<a href="http://www.liaoxuefeng.com/">http://www.liaoxuefeng.com/</a></p>
</li>
</ul>

  </article>

  
  
  
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://unpkg.com/md5/dist/md5.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '29027f13b37b8831bea4',
        clientSecret: '5a25a3157abdda86a35db8a6fcb67273bec66f17',
        repo: 'comments',
        owner: 'justinbetter',
        admin: ['justinbetter'],
        id: MD5(location.pathname),
        distractionFreeMode: false 
    });
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
            return;
        }
        gitalk.render('gitalk-container');
    })();
</script>


</div>

  </main><div class="footer gradient-2">
  <div class="container footer-container ">
    <div class="row">
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        <div class="footer-title">Sitemap</div>
        <ul class="list-unstyled">
            
              
                <li><a href="https://justinbetter.github.io/tags/">Tags</a></li>
              
              
                <li><a href="https://justinbetter.github.io/categories/">Categories</a></li>
              
            
            
            
            <li><a rel="alternate" type="application/rss&#43;xml" href="https://justinbetter.github.io/index.xml"><i class="fas fa-rss-square"></i> RSS Feed</a></li>
            
            
            
        </ul>
      </div>
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        
        <div class="footer-title">Social</div>
        <ul class="list-unstyled">
          
          <li><a href="https://github.com/justinbetter" rel="noopener" target="_blank">GitHub</a></li>
          
        </ul>
        
      </div>
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        
        <div class="footer-title">Links</div>
        <ul class="list-unstyled">
          
          <li><a href="https://github.com/justinbetter" rel="noopener" target="_blank">About Me</a></li>
          
        </ul>
        
      </div>
      <div class="col-xs-12 col-sm-3 col-md-3 col-lg-3">
        <p class="pull-right text-right">
          <small><em>Proudly powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a></em></small><br/>
          <small>
            &copy;
            
            
              2017 -
            2026
          </small>
          
        </p>
      </div>
    </div>
  </div>
</div>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8" />
  <title>Blog of Justin</title>
  <meta name="description" content="Some books of justin" />
  <meta name="author" content="justin" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <meta name="generator" content="kitab theme by Darshan in Hugo 0.69.0" />

  <link
    rel="stylesheet"
    href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
    integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
    crossorigin="anonymous"
  />
  <link
    href="https://fonts.googleapis.com/css?family=Roboto&display=swap"
    rel="stylesheet"
  />
  <link
    rel="stylesheet"
    href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
    integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay"
    crossorigin="anonymous"
  />
  <link rel="stylesheet" href="/css/kitab.css" />

  <script src="/js/myFunctions.js"></script>
  <script src="/js/clipboard.min.js"></script>
</head>

  <body class="container" style="max-width: 1024px;">
    <nav class="mt-2 border-bottom">
  <div class="d-flex flex-row position-relative">
    <a href="/"
      ><i title="Home" class="nav-menu mr-2 mt-1 fas fa-home"></i
    ></a>
    <div class="position-relative">
  <i
    class="nav-menu hover-menu ml-2 mr-2 mt-1 fas fa-book"
    onclick="expandMenu(this)"
    title="Show all books"
  ></i>
  <div
    class="show bg-light shadow mt-2"
    style="position: absolute;
      min-width: 280px;
      max-width: 75%;
      z-index: 1;
      max-height: 0px;
      overflow: hidden;"
  >
    <div class="p-2">
      <strong>
        Blog
      </strong>
      <ul class="list-unstyled ml-1">
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%80%9D%E8%80%83/">
            思考
          </a>
          by justin
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/">
            技术
          </a>
          by justin
        </li>
        
      </ul>
    </div>
  </div>
</div>

    
    <div class="position-relative">
  <i
    class="nav-menu hover-menu ml-2 mr-2 mt-1 fas fa-bars"
    onclick="expandMenu(this)"
    title = "Show Chapters"
  ></i>
  <div
    class="show bg-light shadow mt-2"
    style="
      position: absolute;
      min-width: 280px;
      max-width: 75%;
      z-index: 1;
      max-height: 0px;
      overflow: hidden;"
  >
    <div class="p-2 rounded">
      <strong class="mt-3">
        
        
        技术
        
      </strong>
      <ul class="list-unstyled ml-1">
        
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/mysql/">mysql连招</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/redis/">redis连招</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/leetcode/">算法题目汇总</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/python-learn2/">写python脚本常用的函数</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/python-learn/">python基础</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/git-common/">git常用规范</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/linux-post/">Linux笔记</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/kafka/">Kafka机制一览</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/regexpression/">正则</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/mysqlproblem/">记录类型转换引起的索引失效</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/shell/">学会写shell脚本</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/kotlin/">记录一些kotlin的用法</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/designpattern/">常用的设计模式</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-code2/">【cs基础】编译器的普及</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-algorithm/">【cs基础】如何判断算法的好坏</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-number/">【cs基础】浮点数的存储</a>
        </li>
        
        <li class="hanging">
          <a href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-code/">【cs基础】CPU是怎样执行代码的</a>
        </li>
        
      </ul>
    </div>
  </div>
</div>

    
  </div>
</nav>

    <main class="mt-3" style="margin-left: 32px;">
      
<div class="mb-2 p-3 shadow position-relative">
  <small
    class="bg-white pl-1 pr-1 rounded border border-secondary"
    style="background-color: #f3f3ef !important; position: absolute; top: -0.75em; left: 0.5em"
  >
    技术
  </small>
  <h2>python基础</h2>
  <span style="display: block;opacity: 0.5">2019-08-08</span><br/>
  <div>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a>
      <ul>
        <li><a href="#输出输入">输出输入</a></li>
        <li><a href="#list-和tuple">list 和tuple</a></li>
        <li><a href="#dict和set">dict和set</a></li>
        <li><a href="#函数式编程">函数式编程</a></li>
        <li><a href="#面向对象编程">面向对象编程</a></li>
        <li><a href="#错误处理">错误处理</a></li>
        <li><a href="#输出输入-1">输出输入</a></li>
        <li><a href="#list-和tuple-1">list 和tuple</a></li>
        <li><a href="#dict和set-1">dict和set</a></li>
        <li><a href="#函数式编程-1">函数式编程</a></li>
        <li><a href="#面向对象编程-1">面向对象编程</a></li>
        <li><a href="#错误处理-1">错误处理</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
  <div class="rounded">
    <p>[TOC]</p>
<h2 id="基础">基础</h2>
<p>继承： “定义子类时，必须在括号内指定父类的名称。”
class ElectricCar(Car):</p>
<p>“类名应采用驼峰命名法 ，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。”</p>
<h3 id="输出输入">输出输入</h3>
<ul>
<li>print()</li>
<li>input()</li>
</ul>
<p>###数据类型</p>
<ul>
<li>整数</li>
<li>浮点数</li>
<li>字符串</li>
<li>布尔值</li>
<li>空值 None</li>
<li>变量</li>
<li>常量</li>
</ul>
<p>###字符编码</p>
<ul>
<li>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间</li>
<li>ord() 获取整数表示</li>
<li>chr() 编码转化为字符</li>
<li>encode(&lsquo;ascii&rsquo;) str编码为指定的byte作为网络传输</li>
<li>decode(&lsquo;utf-8&rsquo;)  byte变为str读取网络字节流</li>
<li>len()</li>
<li>格式化 %d %f %s %x</li>
</ul>
<h3 id="list-和tuple">list 和tuple</h3>
<ul>
<li>
<p>list  [1,3,2]</p>
<ul>
<li>len()</li>
<li>append()</li>
<li>insert()</li>
<li>pop()</li>
</ul>
</li>
<li>
<p>tuple 另一种有序列表，一经初始化不能修改</p>
<ul>
<li>(1,)</li>
<li>和list的区别就是不可变</li>
</ul>
</li>
</ul>
<p>###条件判断</p>
<ul>
<li>if : &hellip;elif:&hellip; else:&hellip;.
###循环</li>
<li>for..in..</li>
<li>for x in &hellip;循环就是把每个元素代入变量x，然后执行缩进块的语句。</li>
<li>range()</li>
<li>while x&gt;0:&hellip;</li>
<li>break 退出循环</li>
<li>continue  跳过</li>
</ul>
<h3 id="dict和set">dict和set</h3>
<ul>
<li>
<p>dict  {&lsquo;Michael&rsquo;: 95, &lsquo;Bob&rsquo;: 75, &lsquo;Tracy&rsquo;: 85}</p>
<ul>
<li>类似map，键值对</li>
<li>判断key是否存在
- ’a‘ in dict 通过in
- d.get(&lsquo;Thomas&rsquo;, -1)</li>
<li>pop(key) 删除指定键值对</li>
</ul>
</li>
<li>
<p>set 只包含key的集合{1,2，3}</p>
<ul>
<li>add()</li>
<li>remove()</li>
<li>两个set 可以做&amp; |</li>
</ul>
</li>
</ul>
<p>###函数</p>
<ul>
<li>
<p>abs()</p>
</li>
<li>
<p>max()</p>
</li>
<li>
<p>数据类型转换</p>
<ul>
<li>int(&lsquo;123&rsquo;)</li>
<li>float()</li>
<li>str()</li>
<li>bool()</li>
</ul>
</li>
<li>
<p>定义函数 def my_function(x):&hellip;</p>
</li>
<li>
<p>导入函数 from demo1 import my_function</p>
</li>
<li>
<p>pass 什么都不做</p>
</li>
<li>
<p>isinstance(x,(int, float))</p>
</li>
<li>
<p>参数</p>
<ul>
<li>位置参数</li>
<li>默认参数 def power(x, n=2):..</li>
<li>可变参数 def calc(*number):&hellip;return sum 在函数调用时自动组装为一个tuple</li>
<li>关键字参数 def person(name,age,**kw):&hellip;传入任意dict</li>
<li>命名关键字参数 def person(name,age,*,city,job):&hellip; 调用时必须写key参数名</li>
</ul>
</li>
<li>
<p>递归函数</p>
<ul>
<li>
<p>尾递归优化（没做优化，也没啥用，依然可能栈溢出）</p>
<pre><code> def fact(n):
   return fact_iter(n,1)

 def fact_iter(num,product):
   if num == 1:
       retutn 1
   return fact_iter(num-1,num*product)
</code></pre>
</li>
</ul>
</li>
</ul>
<p>###特性</p>
<ul>
<li>
<p>切片</p>
<ul>
<li>L[0:10] 取0-9，0可以省略，指取10个</li>
<li>L[-10:] 取倒数10个元素</li>
<li>L[::5] 所有数每5个取一个</li>
<li>list、tuple、str 都可以用切片操作</li>
</ul>
</li>
<li>
<p>迭代</p>
<ul>
<li>list、tuple 直接for&hellip;in..</li>
<li>dict
<ul>
<li>for key in d</li>
<li>for value in d.values()</li>
<li>for k,v in d.items()</li>
</ul>
</li>
<li>字符串 for ch in &lsquo;ABC&rsquo;:</li>
<li>list 使用下标循环 for i,value in enumerate([&lsquo;A&rsquo;,&lsquo;B&rsquo;,&lsquo;C&rsquo;]):</li>
</ul>
</li>
<li>
<p>列表生成式</p>
<ul>
<li>创建list的生成式</li>
<li>[x*x for x in range(1,11) if x % 2 ==0]</li>
<li>还可以两层循环 [m + n for m in &lsquo;ABC for n in &lsquo;XYZ&rsquo;]</li>
<li>也可以使用两个变量 [k +'='+v for k,v in d.items()]</li>
</ul>
</li>
<li>
<p>生成器</p>
<ul>
<li>generator 一边循环一边计算的机制</li>
<li>创建方法：
<ul>
<li>
<p>g = (x * x for x in range(10)) 把一个列表生成式的[]改成()</p>
</li>
<li>
<p>next（g) 获得下一个返回值</p>
</li>
<li>
<p>for n in g:&hellip; 可以迭代循环generator</p>
</li>
<li>
<p>推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现</p>
<pre><code>  def fib(max) :
      n,a,b = 0,0,1
      while n&lt; max:
          yield b
          a,b = b,a+b
          n = n + 1
      return 'done'
</code></pre>
</li>
<li>
<p>yield 使函数变成一个generator</p>
</li>
<li>
<p>for 循环调用generator时想拿到返回值必须捕获StopIteration</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>迭代器</p>
<ul>
<li>Iterable 可直接作用for循环的对象 list、tuple、dict、set、str、generator</li>
<li>Iterator 迭代器，可以被next()函数调用并不断返回下一个值的对象</li>
<li>isinstance</li>
<li>from collections import Iterator</li>
</ul>
</li>
</ul>
<h3 id="函数式编程">函数式编程</h3>
<ul>
<li>
<p>高阶函数 一个函数可以接受另一个函数作为参数</p>
<pre><code>  def add(a,b,f):
      return  f(a) +ｆ（ｂ）
</code></pre>
<ul>
<li>
<p><strong>map()</strong> 接收函数和Iterable，返回Iterator</p>
<pre><code>   list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
</code></pre>
</li>
<li>
<p>**reduce()**接受函数和序列，函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</p>
<pre><code>  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
</li>
<li>
<p><strong>filter()</strong> 过滤序列</p>
<pre><code>  list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
</code></pre>
</li>
<li>
<p><strong>sorted()</strong> 可以对list排序，可以接收一个key函数来实现自定义的排序</p>
<pre><code>   sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
</code></pre>
</li>
</ul>
</li>
<li>
<p>返回函数</p>
<ul>
<li>
<p>高阶函数除了可以接收函数作为参数还可以将函数作为结果值返回</p>
<pre><code>  def lazy_sum(*args):
      def sum():
          ax = 0
          for n in args:
              ax = ax + n
          return ax
      return sum
  f #返回函数
  f() #调用函数
</code></pre>
</li>
<li>
<p>返回函数中不要引用任何可能会变化的变量。</p>
</li>
</ul>
</li>
<li>
<p>匿名函数 lambda x ： x*x</p>
</li>
<li>
<p>装饰器 decorator</p>
<ul>
<li>
<p>函数也是一个对象 也有属性 f.<em>name</em>  拿到f函数的名字</p>
</li>
<li>
<p>decorator就是一个返回函数的高阶函数</p>
<pre><code>  import functools

  def log(func):
      #把原始函数的__name__等属性复制到wrapper()函数
      @functools.wrap(func) 

      def wrapper(*args, **kw):
          print('call %s():' % func.__name__)
          return func(*args, **kw)
      return wrapper

  @log
  def now():
          print('2015-3-25')
    
  把@log放到now()函数的定义处，相当于执行了语句：now = log(now)
</code></pre>
</li>
</ul>
</li>
<li>
<p>偏函数</p>
<pre><code>      import functools
      int2 = functools.partial(int ,base = 2)
      int2('1010101')  #85
</code></pre>
</li>
</ul>
<p>###模块</p>
<pre><code>    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    
    ' a test module '
    
    __author__ = 'Michael Liao'
    
    import sys
    
    def test():
        args = sys.argv
        if len(args)==1:
                print('Hello, world!')
        elif len(args)==2:
            print('Hello, %s!' % args[1])
        else:
            print('Too many arguments!')
    
    if __name__=='__main__':
        test()
</code></pre>
<ul>
<li>
<p>import sys 导入模块</p>
</li>
<li>
<p>sys模块有一个argv变量，用list存储了命令行的所有参数</p>
</li>
<li>
<p>命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，一般用于测试</p>
</li>
<li>
<p>作用域</p>
<ul>
<li>正常函数变量名可以直接引用</li>
<li>_xxx_特殊变量名</li>
<li>_xxx和__xxx非公开的函数private</li>
</ul>
</li>
<li>
<p>安装模块 pip install Pillow</p>
</li>
<li>
<p>模块搜索路径 存放在sys模块的path变量中</p>
<ul>
<li>一是直接修改sys.path，添加要搜索的目录： sys.path.append('/Users/michael/my_py_scripts&rsquo;)</li>
<li>第二种方法是设置环境变量PYTHONPATH</li>
</ul>
</li>
</ul>
<h3 id="面向对象编程">面向对象编程</h3>
<pre><code> class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))
</code></pre>
<ul>
<li>
<p>创建实例直接 bart = Student()</p>
</li>
<li>
<p>__name 双下划线 变成了私有变量，实质是Python解释器对外改成了_Student__name</p>
</li>
<li>
<p>继承</p>
<pre><code>   class Dog（Animal）:
      def run(self):
          print(Dog is running...)
      def eat(self):
          print(Dog is eating...)
</code></pre>
</li>
<li>
<p>获取对象信息</p>
<ul>
<li>type()</li>
<li>isinstance(&lsquo;a&rsquo;,str)</li>
<li>dir() 获得对象的所有属性和方法</li>
<li>操作状态 getattr() 、setattr()、hasattr()</li>
</ul>
</li>
<li>
<p>类属性 相当于成员变量</p>
</li>
</ul>
<p>###面向对象高级编程</p>
<ul>
<li>
<p>限制实例的变量</p>
<pre><code>  class Student(object):
      __slot__ = ('name','age') # 用元组定义只允许绑定的属性
</code></pre>
</li>
<li>
<p>为了检查参数使用</p>
<pre><code>  class Student(Object):
            
      @property
      def score(self):
          return self._score

      @score.setter
      def score(self,value):
          if not isinstance(value,int):
              raise ValueError('must be integer')
          if value &lt; 0 or value &gt; 100:
              raise ValueError('more than..')
          self._score = value                
</code></pre>
<ul>
<li>@property      把getter方法变成了属性</li>
<li>@score.setter        @property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值</li>
<li>只定义getter方法@property，不定义setter方法就是一个只读属性：</li>
</ul>
</li>
<li>
<p>多重继承</p>
<ul>
<li>class Dog（Mammal，Runnable）</li>
<li>让某个类除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn</li>
</ul>
</li>
<li>
<p>定制类</p>
<pre><code>  __str__    #print 返回自定义字符串，直接敲变量本质调用__repr__
  __iter__ #返回一个迭代对象 
  __getitem__ # 像list一样可以按下标访问数列的任意一项
  __getattr__  #在没有找到属性的情况下，才调用__getattr__
  __call__     #可以对实例直接调用，callable()判断是否可调用
</code></pre>
</li>
<li>
<p>枚举类</p>
<pre><code>  from enum import Enum
  Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
    
  for name,member in Month.__member__.items():
      print(name,'==&gt;',member,',',member.value)

  #value属性则是自动赋给成员的int常量，默认从1开始计数。
</code></pre>
</li>
</ul>
<hr>
<pre><code>    from enum import Enum, unique
    
    @unique                  #检查没有重复值
    class Weekday(Enum):    #从Enum派生出自定义类
        Sun = 0 # Sun的value被设定为0
        Mon = 1
        Tue = 2
        Wed = 3
        Thu = 4
        Fri = 5
        Sat = 6
</code></pre>
<ul>
<li>元类 metaclass
<ul>
<li>
<p>type() 既可以返回对象的类型，又可以创建出新的类型</p>
<pre><code>  def fn(self,name='world'):
      print('Hello,%s!'%name)
        
  Hello = type('Hello',(object,),dict(hello=fn)) # 创建Hello.class
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="错误处理">错误处理</h3>
<pre><code>    try:
        10 / 0
    except ZeroDivisionError:
        raise ValueError('input error!')
</code></pre>
<ul>
<li>
<p>断言</p>
<pre><code>  def foo(s):
      n = int(s)
      assert n != 0, 'n is zero!'
      return 10 / n
	
  def main():
      foo('0')	
</code></pre>
<ul>
<li>
<p>用-O参数来关闭assert:</p>
<pre><code>  python3 -O err.py	
</code></pre>
</li>
</ul>
</li>
<li>
<p>logging</p>
<pre><code>  import logging
  logging.basicConfig(level=logging.INFO)
	
  s = '0'
  n = int(s)
  logging.info('n = %d' % n)
  print(10 / n)
</code></pre>
</li>
</ul>
<p>###读写文件</p>
<ul>
<li>
<p>读</p>
<pre><code>  with open('path','rb') as f :
      print(f.read())
		
  #二进制 编码 编码错误
   f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')
</code></pre>
</li>
<li>
<p>写</p>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>    with open('/Users/michael/test.txt', 'w') as f:
        f.write('Hello, world!')		
</code></pre>
<ul>
<li>
<p>IO流</p>
<ul>
<li>StringIO</li>
<li>BytesIO</li>
<li></li>
</ul>
</li>
<li>
<p>参考：
<a href="http://www.liaoxuefeng.com/##">http://www.liaoxuefeng.com/##</a>基础</p>
</li>
</ul>
<h3 id="输出输入-1">输出输入</h3>
<ul>
<li>print()</li>
<li>input()</li>
</ul>
<p>###数据类型</p>
<ul>
<li>整数</li>
<li>浮点数</li>
<li>字符串</li>
<li>布尔值</li>
<li>空值 None</li>
<li>变量</li>
<li>常量</li>
</ul>
<p>###字符编码</p>
<ul>
<li>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间</li>
<li>ord() 获取整数表示</li>
<li>chr() 编码转化为字符</li>
<li>encode(&lsquo;ascii&rsquo;) str编码为指定的byte作为网络传输</li>
<li>decode(&lsquo;utf-8&rsquo;)  byte变为str读取网络字节流</li>
<li>len()</li>
<li>格式化 %d %f %s %x</li>
</ul>
<h3 id="list-和tuple-1">list 和tuple</h3>
<ul>
<li>
<p>list  [1,3,2]</p>
<ul>
<li>len()</li>
<li>append()</li>
<li>insert()</li>
<li>pop()</li>
</ul>
</li>
<li>
<p>tuple 另一种有序列表，一经初始化不能修改</p>
<ul>
<li>(1,)</li>
<li>和list的区别就是不可变</li>
</ul>
</li>
</ul>
<p>###条件判断</p>
<ul>
<li>if : &hellip;elif:&hellip; else:&hellip;.
###循环</li>
<li>for..in..</li>
<li>for x in &hellip;循环就是把每个元素代入变量x，然后执行缩进块的语句。</li>
<li>range()</li>
<li>while x&gt;0:&hellip;</li>
<li>break 退出循环</li>
<li>continue  跳过</li>
</ul>
<h3 id="dict和set-1">dict和set</h3>
<ul>
<li>
<p>dict  {&lsquo;Michael&rsquo;: 95, &lsquo;Bob&rsquo;: 75, &lsquo;Tracy&rsquo;: 85}</p>
<ul>
<li>类似map，键值对</li>
<li>判断key是否存在
- ’a‘ in dict 通过in
- d.get(&lsquo;Thomas&rsquo;, -1)</li>
<li>pop(key) 删除指定键值对</li>
</ul>
</li>
<li>
<p>set 只包含key的集合{1,2，3}</p>
<ul>
<li>add()</li>
<li>remove()</li>
<li>两个set 可以做&amp; |</li>
</ul>
</li>
</ul>
<p>###函数</p>
<ul>
<li>
<p>abs()</p>
</li>
<li>
<p>max()</p>
</li>
<li>
<p>数据类型转换</p>
<ul>
<li>int(&lsquo;123&rsquo;)</li>
<li>float()</li>
<li>str()</li>
<li>bool()</li>
</ul>
</li>
<li>
<p>定义函数 def my_function(x):&hellip;</p>
</li>
<li>
<p>导入函数 from demo1 import my_function</p>
</li>
<li>
<p>pass 什么都不做</p>
</li>
<li>
<p>isinstance(x,(int, float))</p>
</li>
<li>
<p>参数</p>
<ul>
<li>位置参数</li>
<li>默认参数 def power(x, n=2):..</li>
<li>可变参数 def calc(*number):&hellip;return sum 在函数调用时自动组装为一个tuple</li>
<li>关键字参数 def person(name,age,**kw):&hellip;传入任意dict</li>
<li>命名关键字参数 def person(name,age,*,city,job):&hellip; 调用时必须写key参数名</li>
</ul>
</li>
<li>
<p>递归函数</p>
<ul>
<li>
<p>尾递归优化（没做优化，也没啥用，依然可能栈溢出）</p>
<pre><code> def fact(n):
   return fact_iter(n,1)

 def fact_iter(num,product):
   if num == 1:
       retutn 1
   return fact_iter(num-1,num*product)
</code></pre>
</li>
</ul>
</li>
</ul>
<p>###特性</p>
<ul>
<li>
<p>切片</p>
<ul>
<li>L[0:10] 取0-9，0可以省略，指取10个</li>
<li>L[-10:] 取倒数10个元素</li>
<li>L[::5] 所有数每5个取一个</li>
<li>list、tuple、str 都可以用切片操作</li>
</ul>
</li>
<li>
<p>迭代</p>
<ul>
<li>list、tuple 直接for&hellip;in..</li>
<li>dict
<ul>
<li>for key in d</li>
<li>for value in d.values()</li>
<li>for k,v in d.items()</li>
</ul>
</li>
<li>字符串 for ch in &lsquo;ABC&rsquo;:</li>
<li>list 使用下标循环 for i,value in enumerate([&lsquo;A&rsquo;,&lsquo;B&rsquo;,&lsquo;C&rsquo;]):</li>
</ul>
</li>
<li>
<p>列表生成式</p>
<ul>
<li>创建list的生成式</li>
<li>[x*x for x in range(1,11) if x % 2 ==0]</li>
<li>还可以两层循环 [m + n for m in &lsquo;ABC for n in &lsquo;XYZ&rsquo;]</li>
<li>也可以使用两个变量 [k +'='+v for k,v in d.items()]</li>
</ul>
</li>
<li>
<p>生成器</p>
<ul>
<li>generator 一边循环一边计算的机制</li>
<li>创建方法：
<ul>
<li>
<p>g = (x * x for x in range(10)) 把一个列表生成式的[]改成()</p>
</li>
<li>
<p>next（g) 获得下一个返回值</p>
</li>
<li>
<p>for n in g:&hellip; 可以迭代循环generator</p>
</li>
<li>
<p>推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现</p>
<pre><code>  def fib(max) :
      n,a,b = 0,0,1
      while n&lt; max:
          yield b
          a,b = b,a+b
          n = n + 1
      return 'done'
</code></pre>
</li>
<li>
<p>yield 使函数变成一个generator</p>
</li>
<li>
<p>for 循环调用generator时想拿到返回值必须捕获StopIteration</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>迭代器</p>
<ul>
<li>Iterable 可直接作用for循环的对象 list、tuple、dict、set、str、generator</li>
<li>Iterator 迭代器，可以被next()函数调用并不断返回下一个值的对象</li>
<li>isinstance</li>
<li>from collections import Iterator</li>
</ul>
</li>
</ul>
<h3 id="函数式编程-1">函数式编程</h3>
<ul>
<li>
<p>高阶函数 一个函数可以接受另一个函数作为参数</p>
<pre><code>  def add(a,b,f):
      return  f(a) +ｆ（ｂ）
</code></pre>
<ul>
<li>
<p><strong>map()</strong> 接收函数和Iterable，返回Iterator</p>
<pre><code>   list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
</code></pre>
</li>
<li>
<p>**reduce()**接受函数和序列，函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</p>
<pre><code>  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
</li>
<li>
<p><strong>filter()</strong> 过滤序列</p>
<pre><code>  list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
</code></pre>
</li>
<li>
<p><strong>sorted()</strong> 可以对list排序，可以接收一个key函数来实现自定义的排序</p>
<pre><code>   sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
</code></pre>
</li>
</ul>
</li>
<li>
<p>返回函数</p>
<ul>
<li>
<p>高阶函数除了可以接收函数作为参数还可以将函数作为结果值返回</p>
<pre><code>  def lazy_sum(*args):
      def sum():
          ax = 0
          for n in args:
              ax = ax + n
          return ax
      return sum
  f #返回函数
  f() #调用函数
</code></pre>
</li>
<li>
<p>返回函数中不要引用任何可能会变化的变量。</p>
</li>
</ul>
</li>
<li>
<p>匿名函数 lambda x ： x*x</p>
</li>
<li>
<p>装饰器 decorator</p>
<ul>
<li>
<p>函数也是一个对象 也有属性 f.<em>name</em>  拿到f函数的名字</p>
</li>
<li>
<p>decorator就是一个返回函数的高阶函数</p>
<pre><code>  import functools

  def log(func):
      #把原始函数的__name__等属性复制到wrapper()函数
      @functools.wrap(func) 

      def wrapper(*args, **kw):
          print('call %s():' % func.__name__)
          return func(*args, **kw)
      return wrapper

  @log
  def now():
          print('2015-3-25')
    
  把@log放到now()函数的定义处，相当于执行了语句：now = log(now)
</code></pre>
</li>
</ul>
</li>
<li>
<p>偏函数</p>
<pre><code>      import functools
      int2 = functools.partial(int ,base = 2)
      int2('1010101')  #85
</code></pre>
</li>
</ul>
<p>###模块</p>
<pre><code>    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    
    ' a test module '
    
    __author__ = 'Michael Liao'
    
    import sys
    
    def test():
        args = sys.argv
        if len(args)==1:
                print('Hello, world!')
        elif len(args)==2:
            print('Hello, %s!' % args[1])
        else:
            print('Too many arguments!')
    
    if __name__=='__main__':
        test()
</code></pre>
<ul>
<li>
<p>import sys 导入模块</p>
</li>
<li>
<p>sys模块有一个argv变量，用list存储了命令行的所有参数</p>
</li>
<li>
<p>命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，一般用于测试</p>
</li>
<li>
<p>作用域</p>
<ul>
<li>正常函数变量名可以直接引用</li>
<li>_xxx_特殊变量名</li>
<li>_xxx和__xxx非公开的函数private</li>
</ul>
</li>
<li>
<p>安装模块 pip install Pillow</p>
</li>
<li>
<p>模块搜索路径 存放在sys模块的path变量中</p>
<ul>
<li>一是直接修改sys.path，添加要搜索的目录： sys.path.append('/Users/michael/my_py_scripts&rsquo;)</li>
<li>第二种方法是设置环境变量PYTHONPATH</li>
</ul>
</li>
</ul>
<h3 id="面向对象编程-1">面向对象编程</h3>
<pre><code> class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))
</code></pre>
<ul>
<li>
<p>创建实例直接 bart = Student()</p>
</li>
<li>
<p>__name 双下划线 变成了私有变量，实质是Python解释器对外改成了_Student__name</p>
</li>
<li>
<p>继承</p>
<pre><code>   class Dog（Animal）:
      def run(self):
          print(Dog is running...)
      def eat(self):
          print(Dog is eating...)
</code></pre>
</li>
<li>
<p>获取对象信息</p>
<ul>
<li>type()</li>
<li>isinstance(&lsquo;a&rsquo;,str)</li>
<li>dir() 获得对象的所有属性和方法</li>
<li>操作状态 getattr() 、setattr()、hasattr()</li>
</ul>
</li>
<li>
<p>类属性 相当于成员变量</p>
</li>
</ul>
<p>###面向对象高级编程</p>
<ul>
<li>
<p>限制实例的变量</p>
<pre><code>  class Student(object):
      __slot__ = ('name','age') # 用元组定义只允许绑定的属性
</code></pre>
</li>
<li>
<p>为了检查参数使用</p>
<pre><code>  class Student(Object):
            
      @property
      def score(self):
          return self._score

      @score.setter
      def score(self,value):
          if not isinstance(value,int):
              raise ValueError('must be integer')
          if value &lt; 0 or value &gt; 100:
              raise ValueError('more than..')
          self._score = value                
</code></pre>
<ul>
<li>@property      把getter方法变成了属性</li>
<li>@score.setter        @property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值</li>
<li>只定义getter方法@property，不定义setter方法就是一个只读属性：</li>
</ul>
</li>
<li>
<p>多重继承</p>
<ul>
<li>class Dog（Mammal，Runnable）</li>
<li>让某个类除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn</li>
</ul>
</li>
<li>
<p>定制类</p>
<pre><code>  __str__    #print 返回自定义字符串，直接敲变量本质调用__repr__
  __iter__ #返回一个迭代对象 
  __getitem__ # 像list一样可以按下标访问数列的任意一项
  __getattr__  #在没有找到属性的情况下，才调用__getattr__
  __call__     #可以对实例直接调用，callable()判断是否可调用
</code></pre>
</li>
<li>
<p>枚举类</p>
<pre><code>  from enum import Enum
  Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
    
  for name,member in Month.__member__.items():
      print(name,'==&gt;',member,',',member.value)

  #value属性则是自动赋给成员的int常量，默认从1开始计数。
</code></pre>
</li>
</ul>
<hr>
<pre><code>    from enum import Enum, unique
    
    @unique                  #检查没有重复值
    class Weekday(Enum):    #从Enum派生出自定义类
        Sun = 0 # Sun的value被设定为0
        Mon = 1
        Tue = 2
        Wed = 3
        Thu = 4
        Fri = 5
        Sat = 6
</code></pre>
<ul>
<li>元类 metaclass
<ul>
<li>
<p>type() 既可以返回对象的类型，又可以创建出新的类型</p>
<pre><code>  def fn(self,name='world'):
      print('Hello,%s!'%name)
        
  Hello = type('Hello',(object,),dict(hello=fn)) # 创建Hello.class
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="错误处理-1">错误处理</h3>
<pre><code>    try:
        10 / 0
    except ZeroDivisionError:
        raise ValueError('input error!')
</code></pre>
<ul>
<li>
<p>断言</p>
<pre><code>  def foo(s):
      n = int(s)
      assert n != 0, 'n is zero!'
      return 10 / n
	
  def main():
      foo('0')	
</code></pre>
<ul>
<li>
<p>用-O参数来关闭assert:</p>
<pre><code>  python3 -O err.py	
</code></pre>
</li>
</ul>
</li>
<li>
<p>logging</p>
<pre><code>  import logging
  logging.basicConfig(level=logging.INFO)
	
  s = '0'
  n = int(s)
  logging.info('n = %d' % n)
  print(10 / n)
</code></pre>
</li>
</ul>
<p>###读写文件</p>
<ul>
<li>
<p>读</p>
<pre><code>  with open('path','rb') as f :
      print(f.read())
		
  #二进制 编码 编码错误
   f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')
</code></pre>
</li>
<li>
<p>写</p>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>    with open('/Users/michael/test.txt', 'w') as f:
        f.write('Hello, world!')		
</code></pre>
<ul>
<li>
<p>IO流</p>
<ul>
<li>StringIO</li>
<li>BytesIO</li>
<li></li>
</ul>
</li>
<li>
<p>参考：
<a href="http://www.liaoxuefeng.com/">http://www.liaoxuefeng.com/</a></p>
</li>
</ul>

  </div>
</div>

    </main>
    <div class="side-bar">
  
  <p class="mb-1 mt-1 text-left">
  
  <a
    href="/%E6%8A%80%E6%9C%AF/git-common/"
    title="git常用规范"
  >
    <i class="nav-menu fas fa-chevron-circle-right"></i>
  </a>
  
</p>
<p class="mb-1 mt-1 text-left">
  
  <a
    href="/%E6%8A%80%E6%9C%AF/python-learn2/"
    title="写python脚本常用的函数"
  >
    <i class="nav-menu fas fa-chevron-circle-left"></i>
  </a>
  
</p>

  
  <p class="mb-1 mt-1 text-left">
    <i
      class="nav-menu fas fa-chevron-circle-up"
      title="Scroll to top"
      onclick="scrollToTop()"
    ></i>
  </p>
  <p class="mb-1 mt-1 text-left">
    <i
      title="Copy URL to share"
      class="nav-menu fas fa-share-alt"
    ></i>
  </p>
</div>

<script>
  function displayCopyMessage(bool) {
    let alertMessage = "";
    if (bool) {
      alertMessage = "Link copied to clipboard";
    } else {
      alertMessage = "Link could not be copied to clipboard";
    }
    let copiedMessage = document.createElement("div");
    copiedMessage.id = "copiedMessage";
    copiedMessage.textContent = alertMessage;
    copiedMessage.classList.add(
      "bg-warning",
      "shadow",
      "d-block",
      "text-center"
    );
    document.body.appendChild(copiedMessage);

    setTimeout(function() {
      copiedMessage.style.opacity = 0;
    }, 500);
    setTimeout(function() {
      document.body.removeChild(copiedMessage);
    }, 1500);
  }

  let clipboard = new ClipboardJS(".fa-share-alt", {
    text: function() {
      return "https:\/\/justinbetter.github.io\/%E6%8A%80%E6%9C%AF\/python-learn\/";
    }
  });

  clipboard.on("success", function() {
    displayCopyMessage(true);
  });

  clipboard.on("error", function() {
    displayCopyMessage(false);
  });
</script>

    <footer class="d-flex flex-row flex-wrap justify-content-between">
  <div class="d-flex flex-column">
    <span class="mb-1">

    </span>
  </div>
  <p class="about text-left mb-0">
  </p>
</footer>

  </body>
</html>

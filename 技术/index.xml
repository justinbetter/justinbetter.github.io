<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术 on Blog of Justin</title>
    <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on Blog of Justin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 15 Jul 2019 20:00:22 +0800</lastBuildDate>
    
	<atom:link href="https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>算法题目汇总</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/leetcode/</link>
      <pubDate>Sat, 15 Aug 2020 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/leetcode/</guid>
      <description>归并排序 public class MergeSort { public static void merge(int[] a, int low, int mid, int high) { int[] temp = new int[high - low + 1]; int i = low;// 左指针  int j = mid + 1;// 右指针  int k = 0; // 把较小的数先移到新数组中  while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= high) { if (a[i] &amp;lt; a[j]) { temp[k++] = a[i++]; } else { temp[k++] = a[j++]; } } // 把左边剩余的数移入数组  while (i &amp;lt;= mid) { temp[k++] = a[i++]; } // 把右边边剩余的数移入数组  while (j &amp;lt;= high) { temp[k++] = a[j++]; } // 把新数组中的数覆盖nums数组  for (int k2 = 0; k2 &amp;lt; temp.</description>
    </item>
    
    <item>
      <title>写python脚本常用的函数</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/python-learn2/</link>
      <pubDate>Fri, 09 Aug 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/python-learn2/</guid>
      <description>@[toc] #python 脚本常用函数
这里记录一些脚本常用的函数
##文件操作
 路径相关  os.chdir(dst_dir)	#改变当前目录 os.listdir()	#遍历文件夹 for root, dirs, files in os.walk(rootDir): #遍历文件夹 os.path.basename() #去掉目录路径, 返回文件名 os.path.splitext() #返回 (filename, extension) 元组 os.path.exists()	#文件存在	shutil.rmtree(zip_comoress_dir) #删除目录 shutil.copy(source_dir, dst_dir)	#复制文件 os.path.dirname(os.path.realpath(__file__)) #获取当前目录  文件信息  json.dumps(mock_config, indent=5)	#获取json数据 os.path.getsize() #获取文件大小 with open(zip_url,&#39;rb&#39;) as f_zip: #解压zip zip_file = zipfile.ZipFile(f_zip) zip_file.extractall(&#39;./zip&#39;) ---------------------------------------- def get_file_md5(f): #获取MD5 m = hashlib.md5() while True: data = f.read(10240) if not data: break m.update(data) return m.</description>
    </item>
    
    <item>
      <title>python基础</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/python-learn/</link>
      <pubDate>Thu, 08 Aug 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/python-learn/</guid>
      <description>[TOC]
基础 继承： “定义子类时，必须在括号内指定父类的名称。” class ElectricCar(Car):
“类名应采用驼峰命名法 ，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。”
输出输入  print() input()  ###数据类型
 整数 浮点数 字符串 布尔值 空值 None 变量 常量  ###字符编码
 UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间 ord() 获取整数表示 chr() 编码转化为字符 encode(&amp;lsquo;ascii&amp;rsquo;) str编码为指定的byte作为网络传输 decode(&amp;lsquo;utf-8&amp;rsquo;) byte变为str读取网络字节流 len() 格式化 %d %f %s %x  list 和tuple   list [1,3,2]
 len() append() insert() pop()    tuple 另一种有序列表，一经初始化不能修改
 (1,) 和list的区别就是不可变    ###条件判断
 if : &amp;hellip;elif:&amp;hellip; else:&amp;hellip;. ###循环 for.</description>
    </item>
    
    <item>
      <title>git常用规范</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/git-common/</link>
      <pubDate>Mon, 15 Jul 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/git-common/</guid>
      <description>分支规范 - 分支规范 1. 分支命名规范： - master: 主线分支 - feature/xxxx: 功能需求开发分支 - hotfix/xxxx: bug 修复分支 - refactor/xxxx: 重构分支 2. 默认从主线分支 checkout 出功能需求 or bug 修复分支 3. 分支合并需要写清本次开发的内容点 - Commit Message 规范 1. 命名规则：func[(main)]: done something - 其中 `[ ]` 中的内容可以省略 2. func 规则： 1. feat: 新功能开发 2. fix: bug 修复 3. refactor: 不影响现有功能的重构 4. test: 添加测试 5. chore: 构建工具改动 6. style: 格式改动 3. 冒号（英文冒号，并空一格）后面写上这次 commit 提交的内容，最好一个小功能点一次提交 4. 禁止类似 `update` 这样无意义的提交！ 查看当前url git remote -v git remote set-url origin [url] git remote rm origin git remote add origin [url] git config user.</description>
    </item>
    
    <item>
      <title>Linux笔记</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/linux-post/</link>
      <pubDate>Sat, 15 Jun 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/linux-post/</guid>
      <description>帮助手册命令 man man命令：可以通过一些参数，快速查询linux帮助手册，并且格式化显示。  ##Linux 下修改 root 密码方法 passwd root
权限 chgrp ：改变文件所属群组 chown -R：改变文件拥有者 chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性	su - user1 切换身份user1  查看服务  /etc/services /etc/init.d/ 启动脚本处	/etc/* ：各服务各自的配置文件 service --status-all 查看所有服务  常用目录 /etc 主要配置文件 /bin 常用执行文件 /sbin 重要的系统执行文件 /dev 存放设备文件 /dev/null 垃圾桶 /home 用户目录 /media /mnt 挂载外部装置 /opt 第三方协议软件 习惯放/usr/local /proc 虚拟文件，存放内存数据:系统cpu、网络.. / (root, 根目录)： 与开机系统有关； /usr (unix software resource)：与软件安装/执行有关； /usr/local/ 自己下载的软件安装目录 /var (variable)： 与系统运作过程有关的常态性变动的文件：缓存、log等。 /etc/issue 配置开机画面显示 /etc/motd 配置登录显示 /etc/ssh/sshd_config ssh配置 ~/.</description>
    </item>
    
    <item>
      <title>学会写shell脚本</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/shell/</link>
      <pubDate>Thu, 01 Mar 2018 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/shell/</guid>
      <description>##shell是什么
 Shell 是一个用C语言编写的程序，它是用户使用Linux的桥梁。 Shell既是一种命令语言，又是一种程序设计语言，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。  ##shell脚本是什么
  shell是为shell编写的脚本程序。
  Bash是大多数Linux系统默认的Shell。
 #! 告诉系统其后路径所指定的程序即是解释此脚本文件的Shell程序。 如： #!/bin/bash    运行方法
 第一种： chmod +x ./test.sh #使脚本具有执行 ./test.sh #执行脚本 第二种： /bin/sh test.sh #运行解释器    ##变量
  使用变量
 your_name=&amp;quot;qinjx&amp;quot; echo $your_name echo ${your_name} #花括号可加可不加    设置只读变量
 myUrl=&amp;quot;http://www.w3cschool.cc&amp;quot; readonly myUrl    删除变量 unset
  ##字符串
  获取长度
 string=&amp;quot;abcd&amp;quot; echo ${#string} #输出 长度4    提取字符串</description>
    </item>
    
    <item>
      <title>记录一些kotlin的用法</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/kotlin/</link>
      <pubDate>Tue, 18 Jul 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/kotlin/</guid>
      <description>操作符 Elvis 操作符 ?: val a = b?.length ?: -1 安全转换 as？  转型不成功返回 null  null safety var a : String? = null a?.length //a 为null 则pass，不为null 则调用 a!!.length// 抛异常 类型判断符 is 范围操作符 : in for(i in 1..5 step 1){} for (i in 5 downTo 1 step 2){} 多行输入符 &amp;quot;&amp;rdquo;&amp;rdquo;  三个双引号之间的内容将被原样保留  扩展函数  run  调用函数块，块内 this指代调用对象 返回值为最后一行  val result = &amp;quot;haha&amp;quot;.run{ println(this) &amp;quot;I&#39;m result&amp;quot; } println(result) apply  同run，函数块内this 指代该对象 返回值为对象自己  let  函数块内 it 指代该对象 返回值最后一行  also  函数块内it 指代该对象 返回值为对象自己  with  将该对象作为函数参数 this 指代该对象 返回值为最后一行  val result = with（&amp;quot;haha&amp;quot;）{ println(this) &amp;quot;result&amp;quot; } println(result) 修饰符  private 只能被自己所在的文件可见，不能在定义这个类之外的文件中使用 protected 可以被成员自己和继承它的成员可见（比如，类和它的子类） internal 对所在的整个module可见 public 最没有限制的修饰符。这是默认的修饰符  委托属性   一个属性具有一些相同的行为，使用lazy或者observable可以被很有趣地实现重用。而不是一次又一次地去声明那些相同的代码</description>
    </item>
    
    <item>
      <title>常用的设计模式</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/designpattern/</link>
      <pubDate>Sun, 28 May 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/designpattern/</guid>
      <description>@[toc] #设计模式
##单例模式
 Double Check Lock  public static Singleton getInstance(){ if(mInstance == null){ synchronized(Singleton.class){ if(mInstance == null){ mInstance = new Singleton(); } } } retuen mInstance; }  静态内部类  public static Singleton getInstance(){ retuen SingletonHolder.sInstance; } private static class SingletonHolder{ private static final Singleton sInstance = new Singleton(); } ​
##Builder模式
 存储参数 设置参数，return this new 对象，传递参数 返回  ##原型模式
 使用  重写clone() 浅拷贝：拷贝对象无法修改原型对象的字段，保证了安全性（除了引用型字段，多以也要拷贝引用性字段） 深拷贝： 对拷贝对象的引用型字段也要拷贝    工厂方法模式 //抽象产品类 public abstract class Dialog(){ public abstract void show(); } public class DialogA extends Dialog{ @Override public void show(){ //showA } } //抽象工厂 public abstract class Factory{ public abstract &amp;lt;T extends Dialog&amp;gt;T createDialog(Class&amp;lt;T&amp;gt; clazz); } public class DialogAFactory extends Factory{ public &amp;lt;T extends Dialog&amp;gt;T createDialog(Class&amp;lt;T&amp;gt; clazz){ Dialog dialog = null; try{ dialog = (Dialog)Class.</description>
    </item>
    
    <item>
      <title>【cs基础】如何判断算法的好坏</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-algorithm/</link>
      <pubDate>Sat, 01 Apr 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-algorithm/</guid>
      <description>@[toc] #算法复杂度
  平时我们说算法的好坏，排除一些软件和硬件上的限制，怎么去衡量这个算法运行的更快呢？这就是Big O notation的作用啦！ ##Big O notation
  Big O notation是一种描述述函数渐进行为的理论，说白了，表达算法的增长趋势，一个算法会渐渐走向快速还是缓慢的表达方式。
  这种渐进表达有三种记号来表示：O、 Θ 和 Ω 记号法。Θ 记号渐进地给出了一个函数的上界和下界，当只有渐近上界时使用 O 记号，当只有渐近下界时使用 Ω 记号。
  譬如：
$T(n)=4n^2+2n+2$
当 n 增大到非常大时，$n^2$ 项将开始占主导地位 , 一般就用$O(n^2)$表示该算法的上界表示算法复杂度。
   ##算法的衡量从两个方向出发：时间复杂度和空间复杂度 ###1. 时间复杂度
 算法完成其执行所需的总时间量 但是！算法执行的时间我们很难真实的估计，只能比较算法语句的执行次数，以此比较时间复杂度  ###2. 空间复杂度
 算法完成其执行所需的计算机存储器的总量 说白了，就是程序执行所需要的内存空间：  指令空间：用于存储已编译版本指令的内存量。 环境堆栈：在函数调用时存储部分执行函数信息的内存量。 数据空间：用于存储所有变量和常量的内存量。 ##怎么做   书读百遍，其义自见。   参考： http://www.cnblogs.com/gaochundong/p/complexity_of_algorithms.html http://www.ehcoo.com/complexity.html</description>
    </item>
    
    <item>
      <title>【cs基础】浮点数的存储</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-number/</link>
      <pubDate>Wed, 29 Mar 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-number/</guid>
      <description>#浮点数的存储 ##为什么讨论浮点数
 计算机只能识别二进制，整数转化为二进制没有任何问题。 但是！浮点数有小数点, 计算机怎么识别！必然要有个规范来规定计算机怎么识别吧！这个规范就是国际标准IEEE 754.  ##浮点数的识别规范
  标准规定，任何浮点数的表现形式为
 V= （-1）^S x M x 2^E 符号位S 尾数位M 指数位E    32bit : 符号位1，指数位8，尾数位23
  64bit : 符号位1，指数位11，尾数位52
  尾数位 M 默认总是1.xxx的形式，秉着优化的概念，标准规定保存的时候可以舍弃，读取的时候再加上，这样尾数范围也增加了 1 位
  指数位2^E , E为8，指数范围0~255; E为11，指数范围 0~2047
  但是！指数E可能为负数 也就是说指数范围可能为-127-128了，为了不出现负数，标准规定采用移位存储，保存的E数据就要+127或者+1023；
  比如E = 10，必须保存成10+127=137，即10001001
   （1）E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。 （2）E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。 （3）E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。
 ##单精度和双精度误差
 十进制转化为二进制的时候，要是永远除不尽，单精度转换为双精度的时候，位数变少，多余的值被省忽略了，就会产生误差的问题  </description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog of Justin</title>
    <link>https://justinbetter.github.io/</link>
    <description>Recent content on Blog of Justin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 05 Sep 2020 20:00:22 +0800</lastBuildDate>
    
	<atom:link href="https://justinbetter.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>redis连招</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/redis/</link>
      <pubDate>Sat, 05 Sep 2020 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/redis/</guid>
      <description>[TOC]
关键字 单线程，epoll，cluster，sentinel，gossip，raft， 分布式锁，穿透，击穿，雪崩，数据一致性， sds，ziplist，skiplist，rehash，hyperloglog， 热key，大key，过期清理，淘汰策略，主从复制，rdb，aof，aof rewrite string,hash,set,zset的底层数据结构实现，hash的渐进式扩容 hyperloglog标准误差多少，原理是啥 再加上 6.0之后的加入的多线程 工作机制 缓存过期重置。锁刷新 一致性哈希算法  分布式锁 setnx讲起，最后慢慢引出set命令的可以加参数， setnx 是SET if Not eXists(如果不存在，则 SET)的简写。万一set value 成功 set time失败 setex是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成。 redisson的锁，就实现了可重入，他使用了LUA的Hash数据结构。
cluster Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。
自动将数据进行分片，每个 master 上放一部分slot数据 提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的 维护数据采用的是gossip协议
节点发现原理： 发送CLUSTER MEET命令握手，meet-pong-ping 握手完成 节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B进行握手，
最终，经过一段时间之后，节点B会被集群中的所有节点认识。 gossip 协议，Gossip协议由MEET、PING、PONG，FAIL种消息实现 每次发送MEET、PING、PONG消息时，发送者都从自己的已知节点列表中随机选出几个节点（可以是主节点或者从节点），并将这两个被选中节点的信息分别保存到两个clusterMsgDataGossip结构里面。
所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。 gossip有一定延迟，因为节点是逐步传播的
Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot）
数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。 当每个slot 都有节点处理的时候，集群才算上线；CRC16（key），MOVED错误重定向到正确节点 跳跃表来保存槽和键之间的关系
主从复制：主节点用于处理槽，而从节点则用于复制某个主节点，替补上线；
（复制：slaveof命令，发送地址-socket连接-ping-pong-replconf-psync） 原理：master负责写，异步同步slave；，从服务器将向主服务器发送PSYNC命令，执行同步操作，
PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partialresynchronization）两种模式： 开启后台线程生成RDB，同时将从客户端收到的所有写命令缓存在内存（内存缓冲区），
RDB完成后 master发送给slave，slave写入本地磁盘，再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。
故障转移： 检测：定期发送ping检测在线，没有在规定时间返回pong消息，标记为pfail，超过半数节点标记，标记fail 转移：选择从节点，选举主节点，转移slot，集群广播自己为主节点 选举：选举新主节点和Sentinel的方法非常相似，两者都是基于Raft算法
哨兵 Redis的高可用性（high availability）解决方案 监视主从节点，执行故障转移</description>
    </item>
    
    <item>
      <title>算法题目汇总</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/leetcode/</link>
      <pubDate>Sat, 15 Aug 2020 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/leetcode/</guid>
      <description>归并排序 public class MergeSort { public static void merge(int[] a, int low, int mid, int high) { int[] temp = new int[high - low + 1]; int i = low;// 左指针  int j = mid + 1;// 右指针  int k = 0; // 把较小的数先移到新数组中  while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= high) { if (a[i] &amp;lt; a[j]) { temp[k++] = a[i++]; } else { temp[k++] = a[j++]; } } // 把左边剩余的数移入数组  while (i &amp;lt;= mid) { temp[k++] = a[i++]; } // 把右边边剩余的数移入数组  while (j &amp;lt;= high) { temp[k++] = a[j++]; } // 把新数组中的数覆盖nums数组  for (int k2 = 0; k2 &amp;lt; temp.</description>
    </item>
    
    <item>
      <title>20个小时</title>
      <link>https://justinbetter.github.io/%E6%80%9D%E8%80%83/20hours/</link>
      <pubDate>Wed, 01 Jul 2020 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%80%9D%E8%80%83/20hours/</guid>
      <description>20个小时 20个小时而已。即使你一开始完全不懂。 只要投入20个小时的时间专心学习某件事，就能提升到让你自己惊讶的水准。
20个小时就够了，大约就是每天45分钟，坚持上一个月，就能学会一项技能。
具体步骤 1. 技能分解 2. 自我纠正 3. 远离导致分心的障碍 4. 至少20小时  </description>
    </item>
    
    <item>
      <title>我的健身指南</title>
      <link>https://justinbetter.github.io/%E6%80%9D%E8%80%83/exercise/</link>
      <pubDate>Sat, 06 Jun 2020 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%80%9D%E8%80%83/exercise/</guid>
      <description>大纲： 是什么？健身的概念 为什么？健身的好处 怎么做？ 健身的原则 健身的方式 健身的时间
最近的八个月在我86小时13分钟的健身统计中，我的身体健康有了显著的提高，在这里写下一些关于健身的心得。
了解健身，拒绝概念模糊
健身是一种系统的锻炼方式，可以最有效地让肌肉发达、结实起来，直到获得富有美感的体形。 健身是一种渐进式过程，这种渐进式训练之所以有效，是因为只要身体所承受的压力比它习惯的大，它就会去适应，从而变得强壮起来”
“不想变得块头太大。怎么办？”我会这样回答他们：“你想成为网球高手，你是否能说你只想学学网球，但是不想打得太好，你不是冲着温布尔顿冠军去的？或者你会让一个职业高尔夫选手教你打高尔夫，但是告诫他说不要把你教得像老虎·伍兹（Tiger Woods）那样棒”
“当我们不去用肌肉，肌肉就开始萎缩和减少。我们不用它们，也就失去了它们。在我们20多岁的时候，这还不明显；到我们30多岁的时候，肌肉萎缩的速度就更快了；而且，随着岁数的增长会越来越快。恩斯特·约克尔（Ernst Jokl）博士说：“一般人在18岁到65岁之间失去了50％的肌肉。” “健身正是抵制肌肉退化的最有效的方式”
“不要担心会变得“过分发达”。你应该担忧的是你现在还剩多少肌肉”
健身训练也可以起到稳定和降低血压的作用（不要使用过重的重量训练，可以使用持续的、大量的训练）；可以增强背部，减少背部问题的出现；同时还可以促使血液流向皮肤，让皮肤活力四射，更有弹性。锻炼可以解压，而压力低的好处不言而喻：既可以提升免疫系统的能力，又可以降低患上癌症和心脏病的风险。
“健身训练还是一种让你的生活变得规律、有节制的好方法，“当你通过训练让你的体质得到增强的时候，你就会变得更加注重饮食习惯”
“千万不要熬夜，浪费太多时间在深夜档的电视节目上。如果你用健身运动来规范你的生活，它不仅会对你的身体和精神产生影响，也会改变你的所作所为，改变你身边的人”
摘录来自: 阿诺德•施瓦辛格. “施瓦辛格健身全书。” Apple Books. 健身正是抵制肌肉退化的最有效的方式 健身正是抵制肌肉退化的最有效的方式
吃的艺术 练习过程 训练感觉
“其实对于有经验的健身者来说，大家知道的技巧都差不多，只是大家运用自己的直觉和感觉的水平造成了人与人之间的差异”
“运动生理学已经确认了健身训练的原理。一般而言，让肌肉最大化发展的方式是，使用单次能举起的最大重量的75％进行训练”
“对于多数人，使用这种重量，可以针对上半身做8～12次反复动作，针对腿部做12～15次反复动作”
“光刺激肌肉增长还是不够的。为了让肌肉增长，还需要让肌肉得到休息，同时吸收足够的营养，这样肌肉才能复原和修复”
“泵感之所以产生，是因为肌肉的运动和心血管系统的压力导致血液流入特定的肌肉区域，可是又不存在同等的压力将血液排出肌肉” “多余的血液将逗留在肌肉内一段时间，这样就会导致肌肉的膨胀”
“训练和随之产生的泵感会产生一系列荷尔蒙反应，其中包括内啡肽和脑啡肽的释放，这两种物质是天然的止痛剂”
“有时，你可能拖着疲惫和懒洋洋的身躯走向健身房，但是只要你训练几分钟之后，就会获得一种奇妙的泵感，突然间就会觉得自己无比强大，精力充沛，能轻而易举地举起眼前的任何重量”
“训练强度大，持续的时间就难以长；即便你状态良好，也是如此。这就是为什么现代的健身者大都分开锻炼身体的各部位，每次训练只着重于少数肌肉，绝不一次针对所有的肌肉进行锻炼”
“高强度的训练之后出现肌肉酸痛是很平常的事情。这种酸痛感是由对肌肉、韧带和肌腱造成的微小损伤的结果”
“造成酸痛还有一个常见的原因，就是在肌肉内堆积了乳酸”
“造成酸痛还有一个常见的原因，就是在肌肉内堆积了乳酸。当肌肉活动产生乳酸的速度比循环系统将其带走的速度快时，乳酸就会堆积起来。当你进行大量的高强度训练之时，乳酸的量就会超过一定的范围，这会给你一种灼伤感，也会在训练后给你一定的酸痛感”
“如果你不好意思给自己的身体拍照，因为你不想见到自己的身材，那么这也就意味着你多么需要进行健身了”
“健身者总是互相询问：“你训练了多长时间？”或者“我要多长时间才能变得那么‘大’？”在他们看来，一个人的肌肉比另外一个发达，只是因为他或者她训练的时间更长。但事实是，并非每个人获得肌肉的速度都是一样快的；也并非每个人都有同样的基因让肌肉同等地生长。
你的基因很大程度上决定了你的身体对训练会怎样反应”
“你的进步速度是被你的基因限定的，但最终的结果则要看你的投入和毅力——那才是最重要的”
训练氛围  非常重要！ “如果你生活在成功的、乐观向上的人中间，你自己就有可能变得成功，变得乐观；如果生长在赤贫的环境中，你身边的人对生活不抱多大希望，精神萎靡，那么你一生都要克服这种环境对你产生的负面影响”
“那些在你身边训练的人也会对你产生影响。如果你身边是一群认真的人，而且训练强度都很大，那么你也会很容易去认真、艰苦地训练。不过，如果你身边的人只是装模作样地做几个动作，那么你也就很难去真正地轰炸你的肌肉。这就是为什么职业的健美运动员总是集结在特定的健身房内”
“对于大多数人来说，在家训练不是为了要取得健身房里的训练效果，只是作为去健身房训练的补充。”
训练技巧  “使用什么方法可以增加强度呢？比如说，你可以：
增加训练重量； 增加每一组中的反复次数； 减少组之间的休息时间； 一次性不间断做两组或者更多组（超级组）。”
“我建议大多数健身者赤手握着重量，让双手变得越来越结实，长出茧来。总之，不要为这些所谓的纱布、手套和其他辅助工具而烦恼了”
“我个人的体验来说，使用这种辅助工具会阻碍手部力量的自然发展”
记录，记忆会骗人，但是客观的信息不会。
“研究和经验都显示，如果一个健身者在每个练习中使用的重量是他能承受的最大重量——也就是说，是他全力以赴完成一次反复时所能达到的最大重量——的70％～75％时，那么效果是最好的”
“上半身肌肉，8～12次反复； 腿部肌肉，12～16次反复”
练到力竭，抛物线式的重量组，热身-活跃，“通过这种训练，可以让你达到最佳的训练效果：从相对较轻的重量开始，这可以让你的肌肉做好充分的热身准备；然后，再使用较重的重量，稍微减少反复次数，这样可以迫使更多的血液流入肌肉中，让你体验到奇妙的泵感；最后，再增加重量，这样训练强度增大，有利于力量和体能的增加”
“健身者们50年的训练经验证明，你能承受的、可以让你完成4组训练的最大重量可以刺激肌肉，让它们生长”
不要借力
热身，心肺训练，简单运动，使用重量 “永远注意，热身要全面彻底。如果你准备用大重量做肩上推举，那么你应该记住，该动作不但会牵涉到三角肌和肱三头肌，还会让颈部肌肉和斜方肌也猛烈收缩，所以也应该给它们以时间去做准备”</description>
    </item>
    
    <item>
      <title>如何自律</title>
      <link>https://justinbetter.github.io/%E6%80%9D%E8%80%83/practise-self-discipline/</link>
      <pubDate>Sun, 10 May 2020 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%80%9D%E8%80%83/practise-self-discipline/</guid>
      <description>  寻找强大动机
By finding his strong reason why
  专注约束自己做好一件事
developing his discipline through singular activities
  预先做好对付诱惑的计划
pre-planning for temptations
  </description>
    </item>
    
    <item>
      <title>世界读书日</title>
      <link>https://justinbetter.github.io/%E6%80%9D%E8%80%83/readday/</link>
      <pubDate>Thu, 23 Apr 2020 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%80%9D%E8%80%83/readday/</guid>
      <description>今天是世界读书日，希望大家象征性地读点书。 我最近发现我的生活里少了很多深度系统的思考，因为我没时间。 我的时间去哪了？ 在王者荣耀、在抖音、在各种新闻论坛里。 这里存在着一种恶性循环： 我越浮躁越看不进书，我就越想放空大脑，将自己投入到无脑的娱乐通俗中； 越是进行这些娱乐活动，我就越浮躁； 娱乐并不可怕，可怕的是总想着娱乐。 养成好的习惯，趋势很重要。 至少在今天这个日子，开卷有益一下。  </description>
    </item>
    
    <item>
      <title>优化自己的写作方式</title>
      <link>https://justinbetter.github.io/%E6%80%9D%E8%80%83/my-first-post/</link>
      <pubDate>Fri, 17 Apr 2020 11:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%80%9D%E8%80%83/my-first-post/</guid>
      <description>发现没有什么动力去记录自己的思考。
纠结的地方有两点：
  优雅的输出环境
  适量的公众注意
   一直以来，我的写作流程是：
在本地的印象笔记完整输出 -&amp;gt;
修正必要的文字格式-&amp;gt;
分别拷贝到微信公众号、简书、知乎专栏、个人博客中。
 如果是这样的流程，每次当我想要动笔写作的时候，心里就会有一种负担：
 “呀？又要来这么一套复杂的工序？搞完以后还没几个人看，算了，没动力了，不写了！”  写作这种事情有很好的正向反馈，作者的动力才能不断持续下去。
 为了不让自己陷入困难的输出环境，我急需要简化自己的输出流程。
目的是为了提升自己的记录动力，不用每次都整这些幺蛾子。
 在搜索一大圈以后，我的方式修改为：
长文章博客在 github 输出，以便于形成一个完整的思考，符合优雅的输出环境；
短文章在微信上发布，吸取适量的公众注意。</description>
    </item>
    
    <item>
      <title>写python脚本常用的函数</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/python-learn2/</link>
      <pubDate>Fri, 09 Aug 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/python-learn2/</guid>
      <description>@[toc] #python 脚本常用函数
这里记录一些脚本常用的函数
##文件操作
 路径相关  os.chdir(dst_dir)	#改变当前目录 os.listdir()	#遍历文件夹 for root, dirs, files in os.walk(rootDir): #遍历文件夹 os.path.basename() #去掉目录路径, 返回文件名 os.path.splitext() #返回 (filename, extension) 元组 os.path.exists()	#文件存在	shutil.rmtree(zip_comoress_dir) #删除目录 shutil.copy(source_dir, dst_dir)	#复制文件 os.path.dirname(os.path.realpath(__file__)) #获取当前目录  文件信息  json.dumps(mock_config, indent=5)	#获取json数据 os.path.getsize() #获取文件大小 with open(zip_url,&#39;rb&#39;) as f_zip: #解压zip zip_file = zipfile.ZipFile(f_zip) zip_file.extractall(&#39;./zip&#39;) ---------------------------------------- def get_file_md5(f): #获取MD5 m = hashlib.md5() while True: data = f.read(10240) if not data: break m.update(data) return m.</description>
    </item>
    
    <item>
      <title>python基础</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/python-learn/</link>
      <pubDate>Thu, 08 Aug 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/python-learn/</guid>
      <description>[TOC]
基础 继承： “定义子类时，必须在括号内指定父类的名称。” class ElectricCar(Car):
“类名应采用驼峰命名法 ，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。”
输出输入  print() input()  ###数据类型
 整数 浮点数 字符串 布尔值 空值 None 变量 常量  ###字符编码
 UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间 ord() 获取整数表示 chr() 编码转化为字符 encode(&amp;lsquo;ascii&amp;rsquo;) str编码为指定的byte作为网络传输 decode(&amp;lsquo;utf-8&amp;rsquo;) byte变为str读取网络字节流 len() 格式化 %d %f %s %x  list 和tuple   list [1,3,2]
 len() append() insert() pop()    tuple 另一种有序列表，一经初始化不能修改
 (1,) 和list的区别就是不可变    ###条件判断
 if : &amp;hellip;elif:&amp;hellip; else:&amp;hellip;. ###循环 for.</description>
    </item>
    
    <item>
      <title>git常用规范</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/git-common/</link>
      <pubDate>Mon, 15 Jul 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/git-common/</guid>
      <description>分支规范 - 分支规范 1. 分支命名规范： - master: 主线分支 - feature/xxxx: 功能需求开发分支 - hotfix/xxxx: bug 修复分支 - refactor/xxxx: 重构分支 2. 默认从主线分支 checkout 出功能需求 or bug 修复分支 3. 分支合并需要写清本次开发的内容点 - Commit Message 规范 1. 命名规则：func[(main)]: done something - 其中 `[ ]` 中的内容可以省略 2. func 规则： 1. feat: 新功能开发 2. fix: bug 修复 3. refactor: 不影响现有功能的重构 4. test: 添加测试 5. chore: 构建工具改动 6. style: 格式改动 3. 冒号（英文冒号，并空一格）后面写上这次 commit 提交的内容，最好一个小功能点一次提交 4. 禁止类似 `update` 这样无意义的提交！ 查看当前url git remote -v git remote set-url origin [url] git remote rm origin git remote add origin [url] git config user.</description>
    </item>
    
    <item>
      <title>Linux笔记</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/linux-post/</link>
      <pubDate>Sat, 15 Jun 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/linux-post/</guid>
      <description>帮助手册命令 man man命令：可以通过一些参数，快速查询linux帮助手册，并且格式化显示。  ##Linux 下修改 root 密码方法 passwd root
权限 chgrp ：改变文件所属群组 chown -R：改变文件拥有者 chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性	su - user1 切换身份user1  查看服务  /etc/services /etc/init.d/ 启动脚本处	/etc/* ：各服务各自的配置文件 service --status-all 查看所有服务  常用目录 /etc 主要配置文件 /bin 常用执行文件 /sbin 重要的系统执行文件 /dev 存放设备文件 /dev/null 垃圾桶 /home 用户目录 /media /mnt 挂载外部装置 /opt 第三方协议软件 习惯放/usr/local /proc 虚拟文件，存放内存数据:系统cpu、网络.. / (root, 根目录)： 与开机系统有关； /usr (unix software resource)：与软件安装/执行有关； /usr/local/ 自己下载的软件安装目录 /var (variable)： 与系统运作过程有关的常态性变动的文件：缓存、log等。 /etc/issue 配置开机画面显示 /etc/motd 配置登录显示 /etc/ssh/sshd_config ssh配置 ~/.</description>
    </item>
    
    <item>
      <title>读和时间作朋友</title>
      <link>https://justinbetter.github.io/%E6%80%9D%E8%80%83/readtime/</link>
      <pubDate>Sun, 03 Mar 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%80%9D%E8%80%83/readtime/</guid>
      <description>看完一本对自己有价值的书--李笑来先生的《和时间作朋友》，总想说点什么。 一开始其实并没有想写这篇文章的冲动，我自己认为我的文笔不算好（样本数量屈指可数的情况下），也没有几个朋友有阅读我文章的冲动，加上主要原因--懒惰，就更没有写的必要了。 为什么又下笔了呢？实在是有与人诉说的需求没有得到满足，本来嘛，一本书写的好，鸡汤满满，整的你热血沸腾的，出于善意的思维，你总是想分享给你的朋友，他们看了，也热血沸腾的，就完事了。于是当我满心欢喜地安利给我的一些朋友以后，我想当然地认为以我不差的审美，他们总该会翻翻看看，了解个大概，再决定是否有精读的必要。结果却并不如此。 我开始思考为什么会出现这样的现象？ 是我不了解他们吗？是不明白他们真正的需要吗？还是他们正处在一个非常繁忙的局面，没有闲暇去读你觉得有价值的东西？抑或只是懒惰罢了？ 我思考后的感悟是，人一生的很多时候会选择相信自己，而不会轻易去听别人的。即便是成功如马云、雷军、李笑来那样的一帮人，推荐自己深有感触的价值读物，依然会有很多人质疑。 下面是我整理的读书笔记。 我们很多人常常面临无法按计划完成任务的困境，生活中的噪音无时无刻不在影响着你的专注力，我们能做的是接受现实，提高心智，相信积累的力量，这是本书的开头。 首先解释了心智的概念：过往获得的一切知识及经验的总和。 心智只要开启了，无论正反，都会自我积累，自我过滤，根深蒂固。而我们以往的经验局限，可能会融入心智，造成拒绝学习的判断，所以为了摆脱局限，我们需要正向地提升自己的心智力量。 如何提高心智？ 开始接受当前现状，在“任务速成”绝无可能的情况下，用自己有的去交换自己要的，如果啥都没有，只能毫不怀疑地相信努力勤奋总会有的。接受现状才是最优策略。 面临的困难？ 由于侯士达法则：完成任务花费的时间总会超过计划的时间--主要原因在于任务有熟悉和陌生的区别。我们要做的是判断任务熟悉程度，接受一定的未知，立即行动。 在行动的过程中不要假装很努力，因为真正重要的事情也会面临枯燥无味，学会三思而后行，what why how，在行动过程中可以考虑把一个非机械的任务和机械的任务并行搭配，养成精细拆分任务的习惯，提高效率。 如果面临焦虑，可以参考柳比歇夫先生的事件时间日志的方式，通过记录自己的时间流量，感知到时间流逝，战胜自己的焦虑。 执行任务的策略？ 定制良好的计划，计划的目的是为了验收，任务执行结束后，对比自己之前记录的标准，想想。 如何学习的主要手段：试错、观察、阅读、正确的思考，同时要考虑个体和群体的经验局限；一个人的自学能力依赖于阅读理解、检索能力、写作能力以及实践能力，永远保持开放的心态，不要‘选择性输入’，只看到自己想看的。 了解一些逻辑常识？ 把权威当作辅助工具。避免一些基础概念不清、因果颠倒、命题关系不分、举证责任、偷换概念等错误，理解双盲测试的概念（病人对药物判断的隔离、工作人员对分发药物的隔离）。 人类普遍拥有的一个认知偏差就是：把成功揽到自己身上，把失败归咎于别人或者坏运气。（这在心理学上有个术语，叫做“自利性偏差(Self-servingBias)”。与其关注成功者，不如多吸取失败者的经验。 道理都明白，可就是做不到的？原因是恐惧和懦弱。办法只有克服。 最好提高一些沟通能力？ 学会倾听，等到对方把话说完再质疑；通过努力、积累成为能说更多话的人，想办法不时做出令人敬佩的事情，就会有人主动找你做朋友；讨论需要双方遵守理性讨论基本原则，真理是独立于个人和群体的，不同变化的只是人们对真理的解释和理解。 往往并不是有兴趣才能做好，而是做好了才有兴趣？ 如何做好？正确的策略加重复。遇到痛苦怎么办？利用大脑的遗忘机制转移痛苦。重复犯错？这是遗忘机制的副作用，可以用文字、图片的方式记录自己当时的尴尬，提醒自己不要去犯同样的错误。 最后提了一些感悟： 浪费时间、虚度年华的人，有一个共同的特征——拼命想控制自己完全不能控制的事物，却在自己真正能掌控的地方彻底失控；不要这样，结果已经在你积累的过程中体现。 接受一个关于运气的现实：概率是独立于任何人存在的，因此绝对不会仅因为我的期望就发生任何变化。 利用鸡尾酒会效应，记录自己可能需要的信息方向，遇到相关信息时注意力就会被潜意识关注。灵巧的勤奋才能迸发灵感。 永远鼓励身边的人，大多数人是以泼水为乐的，别作大多数。 努力的过程中不要忘记给自己留有空间。 选择意味着放弃，选择之前确定自己想要什么。 找到正确的节奏，凡是值得做的事情，都值得慢慢去做，做很久很久。 为值得的人提供帮助。不要试图证明自己，结果反而会适得其反。 大体上来说，这是一本激励人心的书，看完以后倍感热血，对于冷漠太久的内心不算坏事。 最后想想，为什么一定要别人听我的呢？还是心智力量不足啊。想想我分享了美好的东西，这东西本身就是美好的，又哪里缺少欣赏的人呢。 如今我已经记录下来这些感想，至少有个地方听到了。  </description>
    </item>
    
    <item>
      <title>正则</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/regexpression/</link>
      <pubDate>Wed, 18 Jul 2018 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/regexpression/</guid>
      <description>[TOC]
正则 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern）  元字符 一些有特殊含义的字符，帮助建立匹配规则
\ 转义字符 ^ 匹配开始位置 ps：当在一组方括号里使用^是，它表示&amp;quot;非&amp;quot;或&amp;quot;排除&amp;quot;的意思，常常用来剔除某个字符。 $ 匹配结束位置	ps：字符^和$同时使用时，表示精确匹配（字符串与模式一样），分开使用，只匹配字符串首或尾 + 一次或多次 * 0次或多次  ps：
？0次或1次,也可以将默认的贪婪模式转变为非贪婪，例如，对于字符串 &amp;quot;oooo&amp;quot;，&#39;o+?&#39; 将匹配单个 &amp;quot;o&amp;quot;，而 &#39;o+&#39; 将匹配所有 &#39;o&#39;。 （?:pattern) 获取匹配结果，但是不需要存储为分组结果	（?=pattern) 例如，&amp;quot;Windows(?=95|98|NT|2000)&amp;quot;能匹配&amp;quot;Windows2000&amp;quot;中的&amp;quot;Windows&amp;quot;，但不能匹配&amp;quot;Windows3.1&amp;quot;中的&amp;quot;Windows&amp;quot;。 (?!pattern) 例如&amp;quot;Windows(?!95|98|NT|2000)&amp;quot;能匹配&amp;quot;Windows3.1&amp;quot;中的&amp;quot;Windows&amp;quot;，但不能匹配&amp;quot;Windows2000&amp;quot;中的&amp;quot;Windows&amp;quot;。 {n,m} 限定出现次数 *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 [^指定字符串] 指的是除指定字符串以外的其他字符串 [] 匹配其中之一，可匹配字符组的一个列表， （） 可作为子匹配进行分组缓存，分组获取的结果可以通过组编号（从1开始）拿出， **\n访问分组的引用**，可以用来去重 x|y 匹配 x 或 y \s 匹配任何空白字符，包括空格、制表符、换页符等 \S 匹配任何非空白字符 \n 匹配一个换行符 \r 匹配一个回车符 . 匹配除换行符 \n 之外的任何单字符 \b 匹配一个单词边界，是不是在单词的首尾；\B 相反 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \w 匹配字母、数字、下划线。等价于&#39;[A-Za-z0-9_]&#39;。 [a-z] //匹配所有的小写字母 [A-Z] //匹配所有的大写字母 [a-zA-Z] //匹配所有的字母 [0-9] //匹配所有的数字 [0-9\.</description>
    </item>
    
    <item>
      <title>学会写shell脚本</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/shell/</link>
      <pubDate>Thu, 01 Mar 2018 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/shell/</guid>
      <description>##shell是什么
 Shell 是一个用C语言编写的程序，它是用户使用Linux的桥梁。 Shell既是一种命令语言，又是一种程序设计语言，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。  ##shell脚本是什么
  shell是为shell编写的脚本程序。
  Bash是大多数Linux系统默认的Shell。
 #! 告诉系统其后路径所指定的程序即是解释此脚本文件的Shell程序。 如： #!/bin/bash    运行方法
 第一种： chmod +x ./test.sh #使脚本具有执行 ./test.sh #执行脚本 第二种： /bin/sh test.sh #运行解释器    ##变量
  使用变量
 your_name=&amp;quot;qinjx&amp;quot; echo $your_name echo ${your_name} #花括号可加可不加    设置只读变量
 myUrl=&amp;quot;http://www.w3cschool.cc&amp;quot; readonly myUrl    删除变量 unset
  ##字符串
  获取长度
 string=&amp;quot;abcd&amp;quot; echo ${#string} #输出 长度4    提取字符串</description>
    </item>
    
    <item>
      <title>记录一些kotlin的用法</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/kotlin/</link>
      <pubDate>Tue, 18 Jul 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/kotlin/</guid>
      <description>操作符 Elvis 操作符 ?: val a = b?.length ?: -1 安全转换 as？  转型不成功返回 null  null safety var a : String? = null a?.length //a 为null 则pass，不为null 则调用 a!!.length// 抛异常 类型判断符 is 范围操作符 : in for(i in 1..5 step 1){} for (i in 5 downTo 1 step 2){} 多行输入符 &amp;quot;&amp;rdquo;&amp;rdquo;  三个双引号之间的内容将被原样保留  扩展函数  run  调用函数块，块内 this指代调用对象 返回值为最后一行  val result = &amp;quot;haha&amp;quot;.run{ println(this) &amp;quot;I&#39;m result&amp;quot; } println(result) apply  同run，函数块内this 指代该对象 返回值为对象自己  let  函数块内 it 指代该对象 返回值最后一行  also  函数块内it 指代该对象 返回值为对象自己  with  将该对象作为函数参数 this 指代该对象 返回值为最后一行  val result = with（&amp;quot;haha&amp;quot;）{ println(this) &amp;quot;result&amp;quot; } println(result) 修饰符  private 只能被自己所在的文件可见，不能在定义这个类之外的文件中使用 protected 可以被成员自己和继承它的成员可见（比如，类和它的子类） internal 对所在的整个module可见 public 最没有限制的修饰符。这是默认的修饰符  委托属性   一个属性具有一些相同的行为，使用lazy或者observable可以被很有趣地实现重用。而不是一次又一次地去声明那些相同的代码</description>
    </item>
    
    <item>
      <title>常用的设计模式</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/designpattern/</link>
      <pubDate>Sun, 28 May 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/designpattern/</guid>
      <description>@[toc] #设计模式
##单例模式
 Double Check Lock  public static Singleton getInstance(){ if(mInstance == null){ synchronized(Singleton.class){ if(mInstance == null){ mInstance = new Singleton(); } } } retuen mInstance; }  静态内部类  public static Singleton getInstance(){ retuen SingletonHolder.sInstance; } private static class SingletonHolder{ private static final Singleton sInstance = new Singleton(); } ​
##Builder模式
 存储参数 设置参数，return this new 对象，传递参数 返回  ##原型模式
 使用  重写clone() 浅拷贝：拷贝对象无法修改原型对象的字段，保证了安全性（除了引用型字段，多以也要拷贝引用性字段） 深拷贝： 对拷贝对象的引用型字段也要拷贝    工厂方法模式 //抽象产品类 public abstract class Dialog(){ public abstract void show(); } public class DialogA extends Dialog{ @Override public void show(){ //showA } } //抽象工厂 public abstract class Factory{ public abstract &amp;lt;T extends Dialog&amp;gt;T createDialog(Class&amp;lt;T&amp;gt; clazz); } public class DialogAFactory extends Factory{ public &amp;lt;T extends Dialog&amp;gt;T createDialog(Class&amp;lt;T&amp;gt; clazz){ Dialog dialog = null; try{ dialog = (Dialog)Class.</description>
    </item>
    
    <item>
      <title>【cs基础】编译器的普及</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-code2/</link>
      <pubDate>Sun, 02 Apr 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-code2/</guid>
      <description>##编译器是什么 编译器就是一种翻译程序，一般是将高级语言编写的源代码转化成汇编或者机器码。说白了就是把我们用python,java等各种语言写的程序,翻译成计算机能看懂的二进制指令数据,以便运行.
##编译流程
 source &amp;ndash;&amp;gt; 词法分析 == 各种记号Token stream &amp;ndash;&amp;gt; 语法分析 == 语法树 &amp;ndash;&amp;gt; 语义分析 == 优化后的语法树 &amp;ndash;&amp;gt; 中间代码生成 == 中间代码 &amp;ndash;&amp;gt; 中间代码优化 == 优化后的中间代码 &amp;ndash;&amp;gt; 目标代码生成 == 目标代码 &amp;ndash;&amp;gt; 目标代码优化 == target program
 ##流程详解
  词法分析
 将源代码的标识符、运算符等分割成一个个记号    语法分析
 解析得到的一个个记号，根据语法规则生成一种抽象语法树  [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kaiAzFVr-1598890932828)(http://pandolia.net/tinyc/images/syntax_tree-2.png)]
  语义分析
 编译器开始对语法树进行一次或多次的遍历，检查程序的语义规则：变量声明、类型匹配..等    IR生成（中间代码，intermediate Representation）
 一般生成的算法是一个递归的算法，递归的遍历语法树，将语法树上的一些节点替换成中间代码块，再根据特定的规则和顺序将这些中间代码块拼装起来。 为什么不直接生成目标代码？增加编译器的开发扩展性；便于对代码优化，中间代码的优化要比直接在目标代码优化难度低得多。    IR优化
 各种优化： 去除冗余代码 优化循环、算术表达式等    目标代码生成</description>
    </item>
    
    <item>
      <title>【cs基础】如何判断算法的好坏</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-algorithm/</link>
      <pubDate>Sat, 01 Apr 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-algorithm/</guid>
      <description>@[toc] #算法复杂度
  平时我们说算法的好坏，排除一些软件和硬件上的限制，怎么去衡量这个算法运行的更快呢？这就是Big O notation的作用啦！ ##Big O notation
  Big O notation是一种描述述函数渐进行为的理论，说白了，表达算法的增长趋势，一个算法会渐渐走向快速还是缓慢的表达方式。
  这种渐进表达有三种记号来表示：O、 Θ 和 Ω 记号法。Θ 记号渐进地给出了一个函数的上界和下界，当只有渐近上界时使用 O 记号，当只有渐近下界时使用 Ω 记号。
  譬如：
$T(n)=4n^2+2n+2$
当 n 增大到非常大时，$n^2$ 项将开始占主导地位 , 一般就用$O(n^2)$表示该算法的上界表示算法复杂度。
   ##算法的衡量从两个方向出发：时间复杂度和空间复杂度 ###1. 时间复杂度
 算法完成其执行所需的总时间量 但是！算法执行的时间我们很难真实的估计，只能比较算法语句的执行次数，以此比较时间复杂度  ###2. 空间复杂度
 算法完成其执行所需的计算机存储器的总量 说白了，就是程序执行所需要的内存空间：  指令空间：用于存储已编译版本指令的内存量。 环境堆栈：在函数调用时存储部分执行函数信息的内存量。 数据空间：用于存储所有变量和常量的内存量。 ##怎么做   书读百遍，其义自见。   参考： http://www.cnblogs.com/gaochundong/p/complexity_of_algorithms.html http://www.ehcoo.com/complexity.html</description>
    </item>
    
    <item>
      <title>【cs基础】浮点数的存储</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-number/</link>
      <pubDate>Wed, 29 Mar 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-number/</guid>
      <description>#浮点数的存储 ##为什么讨论浮点数
 计算机只能识别二进制，整数转化为二进制没有任何问题。 但是！浮点数有小数点, 计算机怎么识别！必然要有个规范来规定计算机怎么识别吧！这个规范就是国际标准IEEE 754.  ##浮点数的识别规范
  标准规定，任何浮点数的表现形式为
 V= （-1）^S x M x 2^E 符号位S 尾数位M 指数位E    32bit : 符号位1，指数位8，尾数位23
  64bit : 符号位1，指数位11，尾数位52
  尾数位 M 默认总是1.xxx的形式，秉着优化的概念，标准规定保存的时候可以舍弃，读取的时候再加上，这样尾数范围也增加了 1 位
  指数位2^E , E为8，指数范围0~255; E为11，指数范围 0~2047
  但是！指数E可能为负数 也就是说指数范围可能为-127-128了，为了不出现负数，标准规定采用移位存储，保存的E数据就要+127或者+1023；
  比如E = 10，必须保存成10+127=137，即10001001
   （1）E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。 （2）E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。 （3）E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。
 ##单精度和双精度误差
 十进制转化为二进制的时候，要是永远除不尽，单精度转换为双精度的时候，位数变少，多余的值被省忽略了，就会产生误差的问题  </description>
    </item>
    
    <item>
      <title>【cs基础】CPU是怎样执行代码的</title>
      <link>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-code/</link>
      <pubDate>Fri, 17 Mar 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/%E6%8A%80%E6%9C%AF/cs-code/</guid>
      <description>##基础概念
 程序是指令和数据的组合体，被复制到内存才能运行。 内存地址是保存指令和数据的场所，通过地址标记。 CPU 能识别和执行的只有机器语言。  ##CPU 结构 CPU 内部由寄存器、控制器、运算器和时钟四个部分构成，由电流信号相互连通
 寄存器： 保存指令、数据 控制器： 读取内存输入寄存器，控制指令流转 运算器： 运算寄存器中的数据 时钟：发出计时信号，代表运算速度  ##寄存器 程序是把寄存器作为对象来描述的，程序运行就是依赖寄存器的控制。
 存储的内容既可以是指令也可以是数据 数据分为“用于运算的数值”和“表示内存地址的数值”两种。数据种类不同，存储该数值的寄存器也不同   累加寄存器 &amp;ndash;&amp;gt; 运算的数值 基址寄存器和变址寄存器 &amp;ndash;&amp;gt; 表示内存地址的数值 标志寄存器 &amp;ndash;&amp;gt; 运算处理后的CPU的状态 程序计数器 &amp;ndash;&amp;gt; 下一条指令所在内存的地址 栈寄存器 &amp;ndash;&amp;gt; 栈区域的起始地址
 ##程序函数的处理
 机器语言的 call 指令和 return 指令能够解决这个问题。函数调用使用的是 call 指令，而不是跳转指令。在将函数的入口地址设定到程序计数器之前，call 指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行 return 命令。return 命令的功能是把保存在栈中的地址设定到程序计数器中  ##CPU 处理 CPU 能执行的主要机器语言指令
   数据转送指令 &amp;ndash;&amp;gt; 寄存器和内存、内存和内存、寄存器和外围设备之间的数据读写操作 运算指令 &amp;ndash;&amp;gt; 用累加寄存器执行算术运算、逻辑运算、比较运算和移位运算 跳转指令 &amp;ndash;&amp;gt; 实现条件分支、循环、强制跳转等 call/return指令 &amp;ndash;&amp;gt; 函数的调用/返回调用前的地址  参考： 《程序是怎样跑起来的》一书 http://cs.</description>
    </item>
    
  </channel>
</rss>
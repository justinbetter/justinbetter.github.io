<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:webfeeds="http://webfeeds.org/rss/1.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>技术 on Helio</title>
    <link>https://justinbetter.github.io/posts/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on Helio</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 15 Jul 2019 20:00:22 +0800</lastBuildDate>
    
    <atom:link href="https://justinbetter.github.io/posts/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>mysql连招</title>
      <link>https://justinbetter.github.io/2020/09/05/mysql%E8%BF%9E%E6%8B%9B/</link>
      <pubDate>Sat, 05 Sep 2020 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2020/09/05/mysql%E8%BF%9E%E6%8B%9B/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&#34;关键词&#34;&gt;关键词&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;B树，B+树，红黑树，联合索引存储
主从复制，宕机恢复，8.0相比5.0的改进
事务，隔离级别，实现原理，MVCC
在线改表原理，redolog,undolog,binlog，group commit原理问题解决
零拷贝的场景，主键自增id而不是uuid
什么场景使用索引不使用更慢，
锁的数据结构
分库分表扩容，当nosql，开发mysql引擎如何接口对接
死锁，
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;谈谈主从复制&#34;&gt;谈谈主从复制&lt;/h2&gt;
&lt;p&gt;复制（replication）是MySQL数据库提供的一种高可用高性能的解决方案，一般用来建立大型的应用。
replication的工作原理分为以下3个步骤：&lt;br&gt;
1）主服务器（master）把数据更改记录到二进制日志（binlog）中。&lt;br&gt;
2）从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>[TOC]</p>
<h2 id="关键词">关键词</h2>
<pre><code>B树，B+树，红黑树，联合索引存储
主从复制，宕机恢复，8.0相比5.0的改进
事务，隔离级别，实现原理，MVCC
在线改表原理，redolog,undolog,binlog，group commit原理问题解决
零拷贝的场景，主键自增id而不是uuid
什么场景使用索引不使用更慢，
锁的数据结构
分库分表扩容，当nosql，开发mysql引擎如何接口对接
死锁，
</code></pre>
<h2 id="谈谈主从复制">谈谈主从复制</h2>
<p>复制（replication）是MySQL数据库提供的一种高可用高性能的解决方案，一般用来建立大型的应用。
replication的工作原理分为以下3个步骤：<br>
1）主服务器（master）把数据更改记录到二进制日志（binlog）中。<br>
2）从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。</p>
<pre><code>从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL线程，复制执行中继日志
</code></pre>
<p>3）从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性</p>
<p>异步实时
中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大</p>
<h2 id="事务">事务</h2>
<p>在事务中的操作，要么都做修改，要么都不做
分类：扁平、带有保存点、链事务、嵌套事务、分布式事务</p>
<p>原子性、一致性、持久性通过数据库的redo log和undo log来完成。
redo log称为重做日志，用来保证事务的原子性和持久性。
undo log用来保证事务的一致性</p>
<p>redo log：两部分组成 <br>
一是内存中的重做日志缓冲（redo log buffer），其是易失的；<br>
二是重做日志文件（redo log file），其是持久的</p>
<p>binlog<br>
二进制日志（binlog），其用来进行POINT-IN-TIME（PIT）的恢复及主从复制（Replication）环境的建
redo 区别：
产生：redo是在innodb，binlog是在mysql上层
内容：redo是物理格式日志，记录页修改；binlog是逻辑日志，记录SQL语句
写入时间：redo事务中不断写入，binlog事务提交时写入</p>
<p>恢复：<br>
innodb每次启动都会恢复重做日志 redolog，checkpoint表示已经刷新到磁盘页上的LSN，从checkpoint中开始部分即可</p>
<p>undo：<br>
回滚日志，数据修改时会产生，存放在共享表空间的一个段中
MVCC控制，当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取
undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护</p>
<p>purge：<br>
因为存在MVCC，决定最终是否删除，如果没被任何事务引用，可以删除，之前的删除只是改了个标志
执行清理时，historyList 找undo log 然后再从undo page中找undo log，避免大量随机读写
太长了通过延时操作解决</p>
<p>group commit：<br>
数据库都提供了group commit的功能，即一次fsync可以刷新确保多个事务日志被写入文件
为保证MySQL数据库上层二进制日志的写入顺序和InnoDB层的事务提交顺序一致，MySQL数据库内部使用了prepare_commit_mutex这个锁，会失效<br>
解决：Binary Log Group Commit（BLGC）<br>
binlog放入队列，多个事务可以一次fsync写入，然后直接调用引擎层的group commit即可</p>
<h3 id="隔离级别">隔离级别</h3>
<p>READ UNCOMMITTED
READ COMMITTED
REPEATABLE READ
SERIALIZABLE</p>
<p>InnoDB存储引擎在RR事务隔离级别下，使用Next-Key Lock锁的算法，因此避免幻读的产生。<br>
InnoDB存储引擎在默认的REPEATABLE READ的事务隔离级别下已经能完全保证事务的隔离性要求</p>
<h2 id="锁机制">锁机制</h2>
<h3 id="锁命令">锁命令</h3>
<pre><code>SHOW ENGINE INNODB STATUS
</code></pre>
<h3 id="锁原理">锁原理</h3>
<p>两种标准的行级锁：
共享锁（S Lock），允许事务读一行数据。
排他锁（X Lock），允许事务删除或更新一行数据。</p>
<p>支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁（Intention Lock）
InnoDB存储引擎支持意向锁设计比较简练，其意向锁即为表级别的
1）意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁
2）意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁</p>
<p>意向锁之间是互相兼容的，emmm&hellip;&hellip;那你存在的意义是啥？
但是它会与普通的排他 / 共享锁互斥：
这里的排他 / 共享锁指的都是表锁！！！意向锁不会与行级的共享 / 排他锁互斥！！！</p>
<p>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁</p>
<p>3种行锁的算法，其分别是：<br>
Record Lock：单个行记录上的锁，总锁住索引
Gap Lock：间隙锁，锁定一个范围，但不包含记录本身<br>
Next-Key Lock∶ <br>
Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身；
在查询列是唯一索引下降级为record lock</p>
<h3 id="锁问题">锁问题</h3>
<p>幻读问题：（同一事务读到之前不存在的行）
幻读指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，<br>
第二次的SQL语句可能会返回之前不存在的行</p>
<pre><code>SELECT…FOR UPDATE对读取的行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。  
SELECT…LOCK IN SHARE MODE对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。
</code></pre>
<p>Next-Key Lock解决，锁住范围的插入， 通过对事务加X锁，就避免了这个问题</p>
<p>脏读：（不同事务读到没提交的行）
脏读指的就是在不同的事务下，当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据</p>
<p>不可重复读：（一个事务内两次读到的数据不一样）
脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但是其违反了数据库事务一致性的要求
默认事务隔离级别是READ REPEATABLE，采用Next-Key Lock算法，通过对事务加X锁，避免了不可重复读的现象</p>
<p>死锁:
死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象
除了超时机制，当前数据库还都普遍采用wait-for graph（等待图）的方式来进行死锁检测。</p>
<p>innodb不存在锁升级带来的性能问题。
因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。
因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。</p>
<h2 id="mysql中联合索引的存储方式">mysql中联合索引的存储方式</h2>
<p>联合索引：
多个列索引，也是B+树，键值大于等于2；
键值都是排序的，通过叶子节点可以逻辑上顺序地读出所有数据，
对第二个键值也进行了排序处理，有时可以避免多一次的排序操作，比如某个用户的购买时间</p>
<p>覆盖索引：
从辅助索引就可以查到的记录，不需要查询聚集索引；
比如查主键，查联合索引的（a，b）中的b</p>
<p>聚集索引：
b+树，索引节点和叶子节点，数据都在叶子节点上，顺序排列，相邻页双向链表连接
按照整张表主键构造B+树，叶子节点存放行记录，也称数据页，页间双向链表连接
因为按照主键，每张表只有一个聚集索引
聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。</p>
<p>辅助索引：
叶子节点不包含行数据，包含的是键值和书签（行数据的聚集索引键）
非主键索引树搜索回到主键索引树搜索的过程称为：回表，</p>
<p>何时使用索引经验：
取值范围广，没有什么重复，适合使用B+树索引；性别、地区这种低选择性的没必要；
SHOW INDEX结果中的列Cardinality来观察。</p>
<h2 id="innodb引擎">innodb引擎</h2>
<p>InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放
索引组织的表，数据段即为B+树的叶子节点，索引段即为B+树的非索引节点
B+树索引本身并不能找到具体的一条记录，能找到只是该记录所在的页。数据库把页载入到内存，然后通过Page Directory再进行二叉查找</p>
<p>区别：
事务
外键
聚集索引
行锁
没有保存具体行数</p>
<h2 id="关键特性">关键特性：</h2>
<p>后台线程+内存（缓冲池，LRU列表，FREE，FLUSH，重做日志buff，checkpoint）
插入缓存：判断缓冲池不在则仿佛缓冲对象合并，慢慢插入到Insert BufferB+树
两次写：页的副本还原页，分为内存和共享表空间磁盘，脏页写到buff，到共享表空间磁盘,再同步磁盘
自适应哈希索引:AHI是通过缓冲池的B+树页构造而来,自动根据访问的频率和模式来自动地为某些热点页建立哈希索引
异步IO：优化IO
刷新邻居页：检测该页所在区页的脏页一起刷新</p>
<h2 id="脏页">脏页</h2>
<p>Update或Delete改变页中的记录，此时页是脏的，缓冲池中的页的版本要比磁盘的新
先写重做日志，再修改页记录，便于宕机恢复</p>
<h4 id="检查点">检查点</h4>
<p>Checkpoint之前的页已经刷新回磁盘。数据库只需对Checkpoint后的重做日志进行恢复。这样就大大缩短了恢复的时间。</p>
<h2 id="b树">B+树</h2>
<p>若想最大性能地构造一棵二叉查找树，需要这棵二叉查找树是平衡</p>
<p>平衡二叉树的定义如下：<br>
首先符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度最大差为1 <br>
查询快，维护有时需要多次旋转</p>
<p>B树，减少磁盘IO次数的多叉自平衡树，一个节点可以有多个孩子，顺序排列</p>
<p>B+树是一种特殊的AVL，中间节点不保存数据，只用来索引（b树是每个关键字都保存数据），各叶子节点顺序排列指针连接  <br>
B+树的查找次数，取决于B+树的高度</p>
<h2 id="红黑树">红黑树</h2>
<p>红黑树是在普通二叉树上，节点添加一个颜色属性形成的，同时需要同时满足一些性质：<br>
性质一：节点是红色或者是黑色；<br>
性质二：根节点是黑色；<br>
性质三：每个叶节点（NIL或空节点）是黑色；<br>
性质四：每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）；<br>
性质五：从任一节点到其没个叶节点的所有路径都包含相同数目的黑色节点；</p>
<h2 id="什么场景索引更慢">什么场景索引更慢</h2>
<p>查询中很少使用或者参考的列
只有很少数据值的列
text, image和bit数据类型的
表记录太少，不需要创建索引
频繁更新的字段不适合创建索引，修改性能远远大于检索性能时
某些数据包含大量重复数据，因此他建立索引就没有太大的效果（性别）</p>
<h2 id="mvcc">MVCC</h2>
<p>涉及到一致性非锁定读。
一致性的非锁定读指InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据
读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎会去读取行的一个快照数据
快照数据是指该行的之前版本的数据，该实现是通过undo段来完成</p>
<p>RC下非一致性读总是读取被锁定行的最新一份快照数据
RR下非一致性读总是读取事务开始时的行数据版本</p>
<p>根据比较版本号来处理数据的是否显示，从而达到读取数据的时候不需要加锁</p>
<p>RC、RR 两种隔离级别的事务在执行普通的读操作时，通过访问版本链的方法，使得事务间的读写操作得以并发执行，从而提升系统性能。RC、RR 这两个隔离级别的一个很大不同就是生成 ReadView 的时间点不同，RC 在每一次 SELECT 语句前都会生成一个 ReadView，事务期间会更新，因此在其他事务提交前后所得到的 m_ids 列表可能发生变化，使得先前不可见的版本后续又突然可见了。而 RR 只在事务的第一个 SELECT 语句时生成一个 ReadView，事务操作期间不更新。</p>
<h2 id="80相比50的改进">8.0相比5.0的改进</h2>
<p><a href="https://blog.csdn.net/ren6370/article/details/88414463">https://blog.csdn.net/ren6370/article/details/88414463</a></p>
<p>##全文索引
全文检索通常使用倒排索引来实现
倒排索引同B+树索引一样，也是一种索引结构。它在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。
其拥有两种表现形式：
inverted file index，其表现形式为{单词，单词所在文档的ID}
full inverted index，其表现形式为{单词，（单词所在文档的ID，在具体文档中的位置）}</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>redis连招</title>
      <link>https://justinbetter.github.io/2020/09/05/redis%E8%BF%9E%E6%8B%9B/</link>
      <pubDate>Sat, 05 Sep 2020 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2020/09/05/redis%E8%BF%9E%E6%8B%9B/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&#34;关键字&#34;&gt;关键字&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;单线程，epoll，cluster，sentinel，gossip，raft，  
分布式锁，穿透，击穿，雪崩，数据一致性，  
sds，ziplist，skiplist，rehash，hyperloglog，  
热key，大key，过期清理，淘汰策略，主从复制，rdb，aof，aof rewrite
string,hash,set,zset的底层数据结构实现，hash的渐进式扩容  
hyperloglog标准误差多少，原理是啥
再加上 6.0之后的加入的多线程 工作机制
缓存过期重置。锁刷新
一致性哈希算法
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分布式锁&#34;&gt;分布式锁&lt;/h2&gt;
&lt;p&gt;setnx讲起，最后慢慢引出set命令的可以加参数， &lt;br&gt;
setnx 是SET if Not eXists(如果不存在，则 SET)的简写。万一set value 成功 set time失败
setex是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成。
redisson的锁，就实现了可重入，他使用了LUA的Hash数据结构。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>[TOC]</p>
<h2 id="关键字">关键字</h2>
<pre><code>单线程，epoll，cluster，sentinel，gossip，raft，  
分布式锁，穿透，击穿，雪崩，数据一致性，  
sds，ziplist，skiplist，rehash，hyperloglog，  
热key，大key，过期清理，淘汰策略，主从复制，rdb，aof，aof rewrite
string,hash,set,zset的底层数据结构实现，hash的渐进式扩容  
hyperloglog标准误差多少，原理是啥
再加上 6.0之后的加入的多线程 工作机制
缓存过期重置。锁刷新
一致性哈希算法
</code></pre>
<h2 id="分布式锁">分布式锁</h2>
<p>setnx讲起，最后慢慢引出set命令的可以加参数， <br>
setnx 是SET if Not eXists(如果不存在，则 SET)的简写。万一set value 成功 set time失败
setex是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成。
redisson的锁，就实现了可重入，他使用了LUA的Hash数据结构。</p>
<h2 id="cluster">cluster</h2>
<p>Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p>
<p>自动将数据进行分片，每个 master 上放一部分slot数据
提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的
维护数据采用的是gossip协议</p>
<p>节点发现原理：
发送CLUSTER MEET命令握手，meet-pong-ping 握手完成
节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B进行握手，<br>
最终，经过一段时间之后，节点B会被集群中的所有节点认识。
gossip 协议，Gossip协议由MEET、PING、PONG，FAIL种消息实现
每次发送MEET、PING、PONG消息时，发送者都从自己的已知节点列表中随机选出几个节点（可以是主节点或者从节点），并将这两个被选中节点的信息分别保存到两个clusterMsgDataGossip结构里面。<br>
所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。
gossip有一定延迟，因为节点是逐步传播的</p>
<p>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot）<br>
数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。
当每个slot 都有节点处理的时候，集群才算上线；CRC16（key），MOVED错误重定向到正确节点
跳跃表来保存槽和键之间的关系</p>
<p>主从复制：主节点用于处理槽，而从节点则用于复制某个主节点，替补上线；<br>
（复制：slaveof命令，发送地址-socket连接-ping-pong-replconf-psync）
原理：master负责写，异步同步slave；，从服务器将向主服务器发送PSYNC命令，执行同步操作，<br>
PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partialresynchronization）两种模式：
开启后台线程生成RDB，同时将从客户端收到的所有写命令缓存在内存（内存缓冲区），<br>
RDB完成后 master发送给slave，slave写入本地磁盘，再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。</p>
<p>故障转移：
检测：定期发送ping检测在线，没有在规定时间返回pong消息，标记为pfail，超过半数节点标记，标记fail
转移：选择从节点，选举主节点，转移slot，集群广播自己为主节点
选举：选举新主节点和Sentinel的方法非常相似，两者都是基于Raft算法</p>
<h2 id="哨兵">哨兵</h2>
<p>Redis的高可用性（high availability）解决方案
监视主从节点，执行故障转移</p>
<p>原理：
大部分的哨兵都同意才能判断下线，开始raft选举master
哨兵作用是监控、通知、故障转移
info 获取主从信息
发布订阅功能获取其他哨兵节点的信息
通过向其他节点发送 ping 命令进行心跳检测，判断是否下线。
Raft 算法选举负责故障转移的哨兵，从节点替换，slaveOf通知更新</p>
<p>问题：
主备切换数据丢失：一种是异步复制，一种是脑裂导致的数据丢失</p>
<h2 id="单线程">单线程</h2>
<p>执行 Redis 命令的核心模块是单线程的，而不是整个 Redis 实例就一个线程，Redis 其他模块还有各自模块的线程的。</p>
<p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器。</p>
<p>因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
<p>文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，</p>
<p>文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性</p>
<hr>
<p>IO多路复用：I/O多路复用 (单个线程，通过记录跟踪每个I/O流(sock)的状态，来同时管理多个I/O流）</p>
<p>内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。<br>
epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间</p>
<p>epoll：<br>
epoll内部使用了mmap共享了用户和内核的部分空间，避免了数据的来回拷贝；<br>
epoll基于事件驱动，避免了像select和poll对事件的整个轮询操作</p>
<h2 id="hyperloglog标准误差多少原理是啥">hyperloglog标准误差多少，原理是啥</h2>
<p>如果允许统计在巨量数据面前的误差率在可接受的范围内，<br>
1000万浏览量允许最终统计出少了一两万这样子，可采用HyperLogLog算法来解决上面的计数类似问题
计数存在一定的误差，误差率整体较低。标准误差为 0.81% 。<br>
能够使用极少的内存来统计巨量的数据，只需要12K内存就能统计2^64个数据。</p>
<p>原理：
抛硬币的伯努利实验：无论抛了多少次，只要出现了正面，就记录为一次试验，推导出n和k_max中存在估算关联：n = 2^(k_max)</p>
<p>HyperLogLog是这样做的。对于输入的数据：</p>
<p>通过hash函数，将数据转为比特串，根据存入数据中，转化后的出现了 1 的最大的位置 k_max 来估算存入了多少数据。</p>
<p>分桶就是分多少轮。抽象到计算机存储为单位是比特(bit)，长度为 L 的大数组 S ，<br>
将 S 平均分为 m 组，然后每组所占有的比特个数是平均的，设为 P</p>
<p>在 Redis 中，HyperLogLog设置为：m=16834，p=6，L=16834 * 6。占用内存为=16834 * 6 / 8 / 1024 = 12K）
对应：代入指定的估算公式中即可</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>算法题目汇总</title>
      <link>https://justinbetter.github.io/2020/08/15/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</link>
      <pubDate>Sat, 15 Aug 2020 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2020/08/15/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</guid>
      <description>&lt;h2 id=&#34;归并排序&#34;&gt;归并排序&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MergeSort&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;merge&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; low, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mid, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; high) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;high &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; low &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; low;&lt;span style=&#34;color:#75715e&#34;&gt;// 左指针&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1;&lt;span style=&#34;color:#75715e&#34;&gt;// 右指针&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 把较小的数先移到新数组中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; high) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                temp&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                temp&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 把左边剩余的数移入数组&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; mid) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            temp&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 把右边边剩余的数移入数组&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; high) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            temp&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;k&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 把新数组中的数覆盖nums数组&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; k2 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; temp.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; k2&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;k2 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; low&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;k2&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mergeSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; low, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; high) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (low &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; high) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (low &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; high) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 左边&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            mergeSort(a, low, mid);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 右边&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            mergeSort(a, mid &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1, high);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 左右归并&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            merge(a, low, mid, high);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(a));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { 51, 46, 20, 18, 65, 97, 82, 30, 77, 50 };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mergeSort(a, 0, a.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;排序结果：&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(a));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;快速排序&#34;&gt;快速排序&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;QuickSort&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * 将数组的某一段元素进行划分，小的在左边，大的在右边
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * @param a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * @param start
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * @param end
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * @return
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;divide&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; start, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; end){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;//每次都以最右边的元素作为基准值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; base &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;end&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;//start一旦等于end，就说明左右两个指针合并到了同一位置，可以结束此轮循环。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(start &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; end){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(start &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; end &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;start&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; base)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#75715e&#34;&gt;//从左边开始遍历，如果比基准值小，就继续向右走&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				start&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#75715e&#34;&gt;//上面的while循环结束时，就说明当前的a[start]的值比基准值大，应与基准值进行交换&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(start &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; end){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#75715e&#34;&gt;//交换&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;start&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;start&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;end&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;end&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#75715e&#34;&gt;//交换后，此时的那个被调换的值也同时调到了正确的位置(基准值右边)，因此右边也要同时向前移动一位&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				end&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(start &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; end &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;end&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; base)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#75715e&#34;&gt;//从右边开始遍历，如果比基准值大，就继续向左走&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				end&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#75715e&#34;&gt;//上面的while循环结束时，就说明当前的a[end]的值比基准值小，应与基准值进行交换&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(start &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; end){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#75715e&#34;&gt;//交换&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;start&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;start&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;end&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;end&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#75715e&#34;&gt;//交换后，此时的那个被调换的值也同时调到了正确的位置(基准值左边)，因此左边也要同时向后移动一位&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				start&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;//这里返回start或者end皆可，此时的start和end都为基准值所在的位置&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; end;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * 排序
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * @param a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * @param start
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * @param end
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; start, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; end){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(start &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; end){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#75715e&#34;&gt;//如果只有一个元素，就不用再排下去了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		} 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#75715e&#34;&gt;//如果不止一个元素，继续划分两边递归排序下去&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; partition &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; divide(a, start, end);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			sort(a, start, partition&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			sort(a, partition&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;1, end);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;链表排序&#34;&gt;链表排序&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; ListNode &lt;span style=&#34;color:#a6e22e&#34;&gt;sortList&lt;/span&gt;(ListNode head) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(head &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; head.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; head;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//递归归并排序&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//找到中点，递归中点分割，归并合并&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ListNode slow &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ListNode fast &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//fast走完 slow就是中点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(fast &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;  fast.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            slow &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; slow.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            fast &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fast.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ListNode center&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;  slow.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        slow.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ListNode left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sortList(head);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ListNode right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sortList(center);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ListNode tmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ListNode(0);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ListNode res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tmp;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(left &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (left.&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right.&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                tmp.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                tmp.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            tmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tmp.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//添加尾点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        tmp.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; right : left;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//返回头部&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//-----&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//从底至顶 归并排序&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//获取链表长度，根据每一步，循环断链合并，最后合并的链表超越链表长度即返回结果&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;两数相加&#34;&gt;两数相加&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; ListNode &lt;span style=&#34;color:#a6e22e&#34;&gt;addTwoNumbers&lt;/span&gt;(ListNode l1, ListNode l2) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//思路：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//新建两个辅助node，保存倒序排列的l1 l2，不需要；因为题目本身就是逆序的&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//循环两个node 直到最后一个节点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ListNode left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ListNode right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ListNode tmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ListNode(0);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ListNode res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tmp;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(left &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; 0 : left.&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (right &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; 0 : right.&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;carry;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            carry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 10;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ListNode now &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ListNode(sum&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;10);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            res.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; now;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; res.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (right &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (carry &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            res.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ListNode(carry);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; tmp.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      <content:encoded><![CDATA[<h2 id="归并排序">归并排序</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MergeSort</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> a, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> mid, <span style="color:#66d9ef">int</span> high) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> temp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>high <span style="color:#f92672">-</span> low <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> low;<span style="color:#75715e">// 左指针</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1;<span style="color:#75715e">// 右指针</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 把较小的数先移到新数组中</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;=</span> mid <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;=</span> high) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> a<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>) {
</span></span><span style="display:flex;"><span>                temp<span style="color:#f92672">[</span>k<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">++]</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                temp<span style="color:#f92672">[</span>k<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>j<span style="color:#f92672">++]</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 把左边剩余的数移入数组</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;=</span> mid) {
</span></span><span style="display:flex;"><span>            temp<span style="color:#f92672">[</span>k<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">++]</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 把右边边剩余的数移入数组</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&lt;=</span> high) {
</span></span><span style="display:flex;"><span>            temp<span style="color:#f92672">[</span>k<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>j<span style="color:#f92672">++]</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 把新数组中的数覆盖nums数组</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k2 <span style="color:#f92672">=</span> 0; k2 <span style="color:#f92672">&lt;</span> temp.<span style="color:#a6e22e">length</span>; k2<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            a<span style="color:#f92672">[</span>k2 <span style="color:#f92672">+</span> low<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">[</span>k2<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mergeSort</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> a, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> (low <span style="color:#f92672">+</span> high) <span style="color:#f92672">/</span> 2;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&lt;</span> high) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 左边</span>
</span></span><span style="display:flex;"><span>            mergeSort(a, low, mid);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 右边</span>
</span></span><span style="display:flex;"><span>            mergeSort(a, mid <span style="color:#f92672">+</span> 1, high);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 左右归并</span>
</span></span><span style="display:flex;"><span>            merge(a, low, mid, high);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(Arrays.<span style="color:#a6e22e">toString</span>(a));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> { 51, 46, 20, 18, 65, 97, 82, 30, 77, 50 };
</span></span><span style="display:flex;"><span>        mergeSort(a, 0, a.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;排序结果：&#34;</span> <span style="color:#f92672">+</span> Arrays.<span style="color:#a6e22e">toString</span>(a));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="快速排序">快速排序</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">QuickSort</span> {
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * 将数组的某一段元素进行划分，小的在左边，大的在右边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * @param a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * @param start
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * @param end
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * @return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">divide</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> a, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end){
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//每次都以最右边的元素作为基准值</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> base <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>end<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//start一旦等于end，就说明左右两个指针合并到了同一位置，可以结束此轮循环。</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span>(start <span style="color:#f92672">&lt;</span> end){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">while</span>(start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> a<span style="color:#f92672">[</span>start<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;=</span> base)
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//从左边开始遍历，如果比基准值小，就继续向右走</span>
</span></span><span style="display:flex;"><span>				start<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//上面的while循环结束时，就说明当前的a[start]的值比基准值大，应与基准值进行交换</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(start <span style="color:#f92672">&lt;</span> end){
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//交换</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>start<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>				a<span style="color:#f92672">[</span>start<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>end<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>				a<span style="color:#f92672">[</span>end<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//交换后，此时的那个被调换的值也同时调到了正确的位置(基准值右边)，因此右边也要同时向前移动一位</span>
</span></span><span style="display:flex;"><span>				end<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>			}	
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">while</span>(start <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">&amp;&amp;</span> a<span style="color:#f92672">[</span>end<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;=</span> base)
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//从右边开始遍历，如果比基准值大，就继续向左走</span>
</span></span><span style="display:flex;"><span>				end<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//上面的while循环结束时，就说明当前的a[end]的值比基准值小，应与基准值进行交换</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(start <span style="color:#f92672">&lt;</span> end){
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//交换</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>start<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>				a<span style="color:#f92672">[</span>start<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>end<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>				a<span style="color:#f92672">[</span>end<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//交换后，此时的那个被调换的值也同时调到了正确的位置(基准值左边)，因此左边也要同时向后移动一位</span>
</span></span><span style="display:flex;"><span>				start<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			}	
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//这里返回start或者end皆可，此时的start和end都为基准值所在的位置</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> end;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * 排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * @param a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * @param start
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * @param end
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> a, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(start <span style="color:#f92672">&gt;</span> end){
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//如果只有一个元素，就不用再排下去了</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		} 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//如果不止一个元素，继续划分两边递归排序下去</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> partition <span style="color:#f92672">=</span> divide(a, start, end);
</span></span><span style="display:flex;"><span>			sort(a, start, partition<span style="color:#f92672">-</span>1);
</span></span><span style="display:flex;"><span>			sort(a, partition<span style="color:#f92672">+</span>1, end);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="链表排序">链表排序</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> ListNode <span style="color:#a6e22e">sortList</span>(ListNode head) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> head.<span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> head;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//递归归并排序</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//找到中点，递归中点分割，归并合并</span>
</span></span><span style="display:flex;"><span>        ListNode slow <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        ListNode fast <span style="color:#f92672">=</span> head.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//fast走完 slow就是中点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(fast <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>  <span style="color:#f92672">&amp;&amp;</span>  fast.<span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            slow <span style="color:#f92672">=</span> slow.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>            fast <span style="color:#f92672">=</span> fast.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ListNode center<span style="color:#f92672">=</span>  slow.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        slow.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        ListNode left <span style="color:#f92672">=</span> sortList(head);
</span></span><span style="display:flex;"><span>        ListNode right <span style="color:#f92672">=</span> sortList(center);
</span></span><span style="display:flex;"><span>        ListNode tmp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ListNode(0);
</span></span><span style="display:flex;"><span>        ListNode res <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(left <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> right <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (left.<span style="color:#a6e22e">val</span> <span style="color:#f92672">&lt;</span> right.<span style="color:#a6e22e">val</span>) {
</span></span><span style="display:flex;"><span>                tmp.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> left;
</span></span><span style="display:flex;"><span>                left <span style="color:#f92672">=</span> left.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                tmp.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>                right <span style="color:#f92672">=</span> right.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            tmp <span style="color:#f92672">=</span> tmp.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//添加尾点</span>
</span></span><span style="display:flex;"><span>        tmp.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> left <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> right : left;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//返回头部</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//-----</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//从底至顶 归并排序</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//获取链表长度，根据每一步，循环断链合并，最后合并的链表超越链表长度即返回结果</span>
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="两数相加">两数相加</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#66d9ef">public</span> ListNode <span style="color:#a6e22e">addTwoNumbers</span>(ListNode l1, ListNode l2) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//思路：</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//新建两个辅助node，保存倒序排列的l1 l2，不需要；因为题目本身就是逆序的</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//循环两个node 直到最后一个节点</span>
</span></span><span style="display:flex;"><span>        ListNode left <span style="color:#f92672">=</span> l1;
</span></span><span style="display:flex;"><span>        ListNode right <span style="color:#f92672">=</span> l2;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> carry <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        ListNode tmp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ListNode(0);
</span></span><span style="display:flex;"><span>        ListNode res <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(left <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> right <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> (left <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) <span style="color:#f92672">?</span> 0 : left.<span style="color:#a6e22e">val</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> (right <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) <span style="color:#f92672">?</span> 0 : right.<span style="color:#a6e22e">val</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y <span style="color:#f92672">+</span>carry;
</span></span><span style="display:flex;"><span>            carry <span style="color:#f92672">=</span> sum <span style="color:#f92672">/</span> 10;
</span></span><span style="display:flex;"><span>            ListNode now <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ListNode(sum<span style="color:#f92672">%</span>10);
</span></span><span style="display:flex;"><span>            res.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> now;
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> res.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {left <span style="color:#f92672">=</span> left.<span style="color:#a6e22e">next</span>;}
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (right <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {right <span style="color:#f92672">=</span> right.<span style="color:#a6e22e">next</span>;}
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (carry <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>            res.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ListNode(carry);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> tmp.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>写python脚本常用的函数</title>
      <link>https://justinbetter.github.io/2019/08/09/%E5%86%99python%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 09 Aug 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2019/08/09/%E5%86%99python%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;@[toc]
#python 脚本常用函数&lt;/p&gt;
&lt;p&gt;这里记录一些脚本常用的函数&lt;/p&gt;
&lt;p&gt;##文件操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径相关&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;os.chdir(dst_dir)							#改变当前目录
os.listdir()								#遍历文件夹
for root, dirs, files in os.walk(rootDir):  #遍历文件夹
os.path.basename()  						#去掉目录路径, 返回文件名 
os.path.splitext()  						#返回 (filename, extension) 元组 
os.path.exists()							#文件存在	
shutil.rmtree(zip_comoress_dir) 			#删除目录
shutil.copy(source_dir, dst_dir)			#复制文件
os.path.dirname(os.path.realpath(__file__)) #获取当前目录
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;文件信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;json.dumps(mock_config, indent=5)	 	#获取json数据
os.path.getsize()  						#获取文件大小
with open(zip_url,&amp;#39;rb&amp;#39;) as f_zip:  		#解压zip
     zip_file = zipfile.ZipFile(f_zip)
     zip_file.extractall(&amp;#39;./zip&amp;#39;)
----------------------------------------
def get_file_md5(f): 					#获取MD5
    m = hashlib.md5()

    while True:
        data = f.read(10240)
        if not data:
            break

        m.update(data)
    return m.hexdigest()


with open(YOUR_FILE, &amp;#39;rb&amp;#39;)as f:
    file_md5 = get_file_md5(f)
--------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##字符串操作&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>@[toc]
#python 脚本常用函数</p>
<p>这里记录一些脚本常用的函数</p>
<p>##文件操作</p>
<ul>
<li>路径相关</li>
</ul>
<pre tabindex="0"><code>os.chdir(dst_dir)							#改变当前目录
os.listdir()								#遍历文件夹
for root, dirs, files in os.walk(rootDir):  #遍历文件夹
os.path.basename()  						#去掉目录路径, 返回文件名 
os.path.splitext()  						#返回 (filename, extension) 元组 
os.path.exists()							#文件存在	
shutil.rmtree(zip_comoress_dir) 			#删除目录
shutil.copy(source_dir, dst_dir)			#复制文件
os.path.dirname(os.path.realpath(__file__)) #获取当前目录
</code></pre><ul>
<li>文件信息</li>
</ul>
<pre tabindex="0"><code>json.dumps(mock_config, indent=5)	 	#获取json数据
os.path.getsize()  						#获取文件大小
with open(zip_url,&#39;rb&#39;) as f_zip:  		#解压zip
     zip_file = zipfile.ZipFile(f_zip)
     zip_file.extractall(&#39;./zip&#39;)
----------------------------------------
def get_file_md5(f): 					#获取MD5
    m = hashlib.md5()

    while True:
        data = f.read(10240)
        if not data:
            break

        m.update(data)
    return m.hexdigest()


with open(YOUR_FILE, &#39;rb&#39;)as f:
    file_md5 = get_file_md5(f)
--------------------------------------
</code></pre><p>##字符串操作</p>
<ul>
<li>命令行</li>
</ul>
<pre tabindex="0"><code>    p = subprocess.Popen(COMMAND, stdout=subprocess.PIPE, stderr=None, shell=True)
    p_communicate = p.communicate()   #返回命令行输出
-----------
apk_old = raw_input(&#39;old_path: &#39;) 	  #获取命令
os.system(&#34;cd test&#34;)

    
</code></pre><ul>
<li>字符串包含</li>
</ul>
<pre tabindex="0"><code>if &#34;123&#34;  in &#34;da123dfd&#34;:

s = &#34;This be a string&#34;
if s.find(&#34;is&#34;) == -1:
    print &#34;No &#39;is&#39; here!&#34;
else:
    print &#34;Found &#39;is&#39; in the string.&#34;
</code></pre><ul>
<li>正则匹配</li>
</ul>
<pre tabindex="0"><code> pattern = re.compile(r&#39;package: name=\&#39;(\S+)\&#39;&#39;)
 search  = pattern.search(data)
 result  = search.group(1)  
</code></pre><p>##列表操作</p>
<pre tabindex="0"><code>map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])		#循环操作每一个元素
</code></pre><p>##ps</p>
<ul>
<li>json.dumps输出中文指定ensure_ascii参数为False</li>
</ul>
<p>##转化为exe执行</p>
<ul>
<li>pip install pyinstaller</li>
<li>pyinstaller -F demo.py</li>
<li>cx_freeze: <a href="http://www.cnblogs.com/renzo/archive/2012/01/01/2309260.html">http://www.cnblogs.com/renzo/archive/2012/01/01/2309260.html</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>python基础</title>
      <link>https://justinbetter.github.io/2019/08/08/python%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 08 Aug 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2019/08/08/python%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&#34;基础&#34;&gt;基础&lt;/h2&gt;
&lt;p&gt;继承： “定义子类时，必须在括号内指定父类的名称。”
class ElectricCar(Car):&lt;/p&gt;
&lt;p&gt;“类名应采用驼峰命名法 ，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。”&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>[TOC]</p>
<h2 id="基础">基础</h2>
<p>继承： “定义子类时，必须在括号内指定父类的名称。”
class ElectricCar(Car):</p>
<p>“类名应采用驼峰命名法 ，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。”</p>
<h3 id="输出输入">输出输入</h3>
<ul>
<li>print()</li>
<li>input()</li>
</ul>
<p>###数据类型</p>
<ul>
<li>整数</li>
<li>浮点数</li>
<li>字符串</li>
<li>布尔值</li>
<li>空值 None</li>
<li>变量</li>
<li>常量</li>
</ul>
<p>###字符编码</p>
<ul>
<li>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间</li>
<li>ord() 获取整数表示</li>
<li>chr() 编码转化为字符</li>
<li>encode(&lsquo;ascii&rsquo;) str编码为指定的byte作为网络传输</li>
<li>decode(&lsquo;utf-8&rsquo;)  byte变为str读取网络字节流</li>
<li>len()</li>
<li>格式化 %d %f %s %x</li>
</ul>
<h3 id="list-和tuple">list 和tuple</h3>
<ul>
<li>
<p>list  [1,3,2]</p>
<ul>
<li>len()</li>
<li>append()</li>
<li>insert()</li>
<li>pop()</li>
</ul>
</li>
<li>
<p>tuple 另一种有序列表，一经初始化不能修改</p>
<ul>
<li>(1,)</li>
<li>和list的区别就是不可变</li>
</ul>
</li>
</ul>
<p>###条件判断</p>
<ul>
<li>if : &hellip;elif:&hellip; else:&hellip;.
###循环</li>
<li>for..in..</li>
<li>for x in &hellip;循环就是把每个元素代入变量x，然后执行缩进块的语句。</li>
<li>range()</li>
<li>while x&gt;0:&hellip;</li>
<li>break 退出循环</li>
<li>continue  跳过</li>
</ul>
<h3 id="dict和set">dict和set</h3>
<ul>
<li>
<p>dict  {&lsquo;Michael&rsquo;: 95, &lsquo;Bob&rsquo;: 75, &lsquo;Tracy&rsquo;: 85}</p>
<ul>
<li>类似map，键值对</li>
<li>判断key是否存在
- ’a‘ in dict 通过in
- d.get(&lsquo;Thomas&rsquo;, -1)</li>
<li>pop(key) 删除指定键值对</li>
</ul>
</li>
<li>
<p>set 只包含key的集合{1,2，3}</p>
<ul>
<li>add()</li>
<li>remove()</li>
<li>两个set 可以做&amp; |</li>
</ul>
</li>
</ul>
<p>###函数</p>
<ul>
<li>
<p>abs()</p>
</li>
<li>
<p>max()</p>
</li>
<li>
<p>数据类型转换</p>
<ul>
<li>int(&lsquo;123&rsquo;)</li>
<li>float()</li>
<li>str()</li>
<li>bool()</li>
</ul>
</li>
<li>
<p>定义函数 def my_function(x):&hellip;</p>
</li>
<li>
<p>导入函数 from demo1 import my_function</p>
</li>
<li>
<p>pass 什么都不做</p>
</li>
<li>
<p>isinstance(x,(int, float))</p>
</li>
<li>
<p>参数</p>
<ul>
<li>位置参数</li>
<li>默认参数 def power(x, n=2):..</li>
<li>可变参数 def calc(*number):&hellip;return sum 在函数调用时自动组装为一个tuple</li>
<li>关键字参数 def person(name,age,**kw):&hellip;传入任意dict</li>
<li>命名关键字参数 def person(name,age,*,city,job):&hellip; 调用时必须写key参数名</li>
</ul>
</li>
<li>
<p>递归函数</p>
<ul>
<li>
<p>尾递归优化（没做优化，也没啥用，依然可能栈溢出）</p>
<pre><code> def fact(n):
   return fact_iter(n,1)

 def fact_iter(num,product):
   if num == 1:
       retutn 1
   return fact_iter(num-1,num*product)
</code></pre>
</li>
</ul>
</li>
</ul>
<p>###特性</p>
<ul>
<li>
<p>切片</p>
<ul>
<li>L[0:10] 取0-9，0可以省略，指取10个</li>
<li>L[-10:] 取倒数10个元素</li>
<li>L[::5] 所有数每5个取一个</li>
<li>list、tuple、str 都可以用切片操作</li>
</ul>
</li>
<li>
<p>迭代</p>
<ul>
<li>list、tuple 直接for&hellip;in..</li>
<li>dict
<ul>
<li>for key in d</li>
<li>for value in d.values()</li>
<li>for k,v in d.items()</li>
</ul>
</li>
<li>字符串 for ch in &lsquo;ABC&rsquo;:</li>
<li>list 使用下标循环 for i,value in enumerate([&lsquo;A&rsquo;,&lsquo;B&rsquo;,&lsquo;C&rsquo;]):</li>
</ul>
</li>
<li>
<p>列表生成式</p>
<ul>
<li>创建list的生成式</li>
<li>[x*x for x in range(1,11) if x % 2 ==0]</li>
<li>还可以两层循环 [m + n for m in &lsquo;ABC for n in &lsquo;XYZ&rsquo;]</li>
<li>也可以使用两个变量 [k +&rsquo;=&rsquo;+v for k,v in d.items()]</li>
</ul>
</li>
<li>
<p>生成器</p>
<ul>
<li>generator 一边循环一边计算的机制</li>
<li>创建方法：
<ul>
<li>
<p>g = (x * x for x in range(10)) 把一个列表生成式的[]改成()</p>
</li>
<li>
<p>next（g) 获得下一个返回值</p>
</li>
<li>
<p>for n in g:&hellip; 可以迭代循环generator</p>
</li>
<li>
<p>推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现</p>
<pre><code>  def fib(max) :
      n,a,b = 0,0,1
      while n&lt; max:
          yield b
          a,b = b,a+b
          n = n + 1
      return 'done'
</code></pre>
</li>
<li>
<p>yield 使函数变成一个generator</p>
</li>
<li>
<p>for 循环调用generator时想拿到返回值必须捕获StopIteration</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>迭代器</p>
<ul>
<li>Iterable 可直接作用for循环的对象 list、tuple、dict、set、str、generator</li>
<li>Iterator 迭代器，可以被next()函数调用并不断返回下一个值的对象</li>
<li>isinstance</li>
<li>from collections import Iterator</li>
</ul>
</li>
</ul>
<h3 id="函数式编程">函数式编程</h3>
<ul>
<li>
<p>高阶函数 一个函数可以接受另一个函数作为参数</p>
<pre><code>  def add(a,b,f):
      return  f(a) +ｆ（ｂ）
</code></pre>
<ul>
<li>
<p><strong>map()</strong> 接收函数和Iterable，返回Iterator</p>
<pre><code>   list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
</code></pre>
</li>
<li>
<p>**reduce()**接受函数和序列，函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</p>
<pre><code>  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
</li>
<li>
<p><strong>filter()</strong> 过滤序列</p>
<pre><code>  list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
</code></pre>
</li>
<li>
<p><strong>sorted()</strong> 可以对list排序，可以接收一个key函数来实现自定义的排序</p>
<pre><code>   sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
</code></pre>
</li>
</ul>
</li>
<li>
<p>返回函数</p>
<ul>
<li>
<p>高阶函数除了可以接收函数作为参数还可以将函数作为结果值返回</p>
<pre><code>  def lazy_sum(*args):
      def sum():
          ax = 0
          for n in args:
              ax = ax + n
          return ax
      return sum
  f #返回函数
  f() #调用函数
</code></pre>
</li>
<li>
<p>返回函数中不要引用任何可能会变化的变量。</p>
</li>
</ul>
</li>
<li>
<p>匿名函数 lambda x ： x*x</p>
</li>
<li>
<p>装饰器 decorator</p>
<ul>
<li>
<p>函数也是一个对象 也有属性 f.<em>name</em>  拿到f函数的名字</p>
</li>
<li>
<p>decorator就是一个返回函数的高阶函数</p>
<pre><code>  import functools

  def log(func):
      #把原始函数的__name__等属性复制到wrapper()函数
      @functools.wrap(func) 

      def wrapper(*args, **kw):
          print('call %s():' % func.__name__)
          return func(*args, **kw)
      return wrapper

  @log
  def now():
          print('2015-3-25')

  把@log放到now()函数的定义处，相当于执行了语句：now = log(now)
</code></pre>
</li>
</ul>
</li>
<li>
<p>偏函数</p>
<pre><code>      import functools
      int2 = functools.partial(int ,base = 2)
      int2('1010101')  #85
</code></pre>
</li>
</ul>
<p>###模块</p>
<pre><code>    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    
    ' a test module '
    
    __author__ = 'Michael Liao'
    
    import sys
    
    def test():
        args = sys.argv
        if len(args)==1:
                print('Hello, world!')
        elif len(args)==2:
            print('Hello, %s!' % args[1])
        else:
            print('Too many arguments!')
    
    if __name__=='__main__':
        test()
</code></pre>
<ul>
<li>
<p>import sys 导入模块</p>
</li>
<li>
<p>sys模块有一个argv变量，用list存储了命令行的所有参数</p>
</li>
<li>
<p>命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，一般用于测试</p>
</li>
<li>
<p>作用域</p>
<ul>
<li>正常函数变量名可以直接引用</li>
<li>_xxx_特殊变量名</li>
<li>_xxx和__xxx非公开的函数private</li>
</ul>
</li>
<li>
<p>安装模块 pip install Pillow</p>
</li>
<li>
<p>模块搜索路径 存放在sys模块的path变量中</p>
<ul>
<li>一是直接修改sys.path，添加要搜索的目录： sys.path.append(&rsquo;/Users/michael/my_py_scripts&rsquo;)</li>
<li>第二种方法是设置环境变量PYTHONPATH</li>
</ul>
</li>
</ul>
<h3 id="面向对象编程">面向对象编程</h3>
<pre><code> class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))
</code></pre>
<ul>
<li>
<p>创建实例直接 bart = Student()</p>
</li>
<li>
<p>__name 双下划线 变成了私有变量，实质是Python解释器对外改成了_Student__name</p>
</li>
<li>
<p>继承</p>
<pre><code>   class Dog（Animal）:
      def run(self):
          print(Dog is running...)
      def eat(self):
          print(Dog is eating...)
</code></pre>
</li>
<li>
<p>获取对象信息</p>
<ul>
<li>type()</li>
<li>isinstance(&lsquo;a&rsquo;,str)</li>
<li>dir() 获得对象的所有属性和方法</li>
<li>操作状态 getattr() 、setattr()、hasattr()</li>
</ul>
</li>
<li>
<p>类属性 相当于成员变量</p>
</li>
</ul>
<p>###面向对象高级编程</p>
<ul>
<li>
<p>限制实例的变量</p>
<pre><code>  class Student(object):
      __slot__ = ('name','age') # 用元组定义只允许绑定的属性
</code></pre>
</li>
<li>
<p>为了检查参数使用</p>
<pre><code>  class Student(Object):

      @property
      def score(self):
          return self._score

      @score.setter
      def score(self,value):
          if not isinstance(value,int):
              raise ValueError('must be integer')
          if value &lt; 0 or value &gt; 100:
              raise ValueError('more than..')
          self._score = value                
</code></pre>
<ul>
<li>@property      把getter方法变成了属性</li>
<li>@score.setter        @property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值</li>
<li>只定义getter方法@property，不定义setter方法就是一个只读属性：</li>
</ul>
</li>
<li>
<p>多重继承</p>
<ul>
<li>class Dog（Mammal，Runnable）</li>
<li>让某个类除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn</li>
</ul>
</li>
<li>
<p>定制类</p>
<pre><code>  __str__    #print 返回自定义字符串，直接敲变量本质调用__repr__
  __iter__ #返回一个迭代对象 
  __getitem__ # 像list一样可以按下标访问数列的任意一项
  __getattr__  #在没有找到属性的情况下，才调用__getattr__
  __call__     #可以对实例直接调用，callable()判断是否可调用
</code></pre>
</li>
<li>
<p>枚举类</p>
<pre><code>  from enum import Enum
  Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

  for name,member in Month.__member__.items():
      print(name,'==&gt;',member,',',member.value)

  #value属性则是自动赋给成员的int常量，默认从1开始计数。
</code></pre>
</li>
</ul>
<hr>
<pre><code>    from enum import Enum, unique
    
    @unique                  #检查没有重复值
    class Weekday(Enum):    #从Enum派生出自定义类
        Sun = 0 # Sun的value被设定为0
        Mon = 1
        Tue = 2
        Wed = 3
        Thu = 4
        Fri = 5
        Sat = 6
</code></pre>
<ul>
<li>元类 metaclass
<ul>
<li>
<p>type() 既可以返回对象的类型，又可以创建出新的类型</p>
<pre><code>  def fn(self,name='world'):
      print('Hello,%s!'%name)

  Hello = type('Hello',(object,),dict(hello=fn)) # 创建Hello.class
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="错误处理">错误处理</h3>
<pre><code>	try:
    	10 / 0
	except ZeroDivisionError:
    	raise ValueError('input error!')
</code></pre>
<ul>
<li>
<p>断言</p>
<pre><code>  def foo(s):
      n = int(s)
      assert n != 0, 'n is zero!'
      return 10 / n

  def main():
      foo('0')	
</code></pre>
<ul>
<li>
<p>用-O参数来关闭assert:</p>
<pre><code>  python3 -O err.py	
</code></pre>
</li>
</ul>
</li>
<li>
<p>logging</p>
<pre><code>  import logging
  logging.basicConfig(level=logging.INFO)

  s = '0'
  n = int(s)
  logging.info('n = %d' % n)
  print(10 / n)
</code></pre>
</li>
</ul>
<p>###读写文件</p>
<ul>
<li>
<p>读</p>
<pre><code>  with open('path','rb') as f :
  	print(f.read())

  #二进制 编码 编码错误
   f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')
</code></pre>
</li>
<li>
<p>写</p>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>	with open('/Users/michael/test.txt', 'w') as f:
	    f.write('Hello, world!')		
</code></pre>
<ul>
<li>
<p>IO流</p>
<ul>
<li>StringIO</li>
<li>BytesIO</li>
<li></li>
</ul>
</li>
<li>
<p>参考：
<a href="http://www.liaoxuefeng.com/#%23">http://www.liaoxuefeng.com/##</a>基础</p>
</li>
</ul>
<h3 id="输出输入-1">输出输入</h3>
<ul>
<li>print()</li>
<li>input()</li>
</ul>
<p>###数据类型</p>
<ul>
<li>整数</li>
<li>浮点数</li>
<li>字符串</li>
<li>布尔值</li>
<li>空值 None</li>
<li>变量</li>
<li>常量</li>
</ul>
<p>###字符编码</p>
<ul>
<li>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间</li>
<li>ord() 获取整数表示</li>
<li>chr() 编码转化为字符</li>
<li>encode(&lsquo;ascii&rsquo;) str编码为指定的byte作为网络传输</li>
<li>decode(&lsquo;utf-8&rsquo;)  byte变为str读取网络字节流</li>
<li>len()</li>
<li>格式化 %d %f %s %x</li>
</ul>
<h3 id="list-和tuple-1">list 和tuple</h3>
<ul>
<li>
<p>list  [1,3,2]</p>
<ul>
<li>len()</li>
<li>append()</li>
<li>insert()</li>
<li>pop()</li>
</ul>
</li>
<li>
<p>tuple 另一种有序列表，一经初始化不能修改</p>
<ul>
<li>(1,)</li>
<li>和list的区别就是不可变</li>
</ul>
</li>
</ul>
<p>###条件判断</p>
<ul>
<li>if : &hellip;elif:&hellip; else:&hellip;.
###循环</li>
<li>for..in..</li>
<li>for x in &hellip;循环就是把每个元素代入变量x，然后执行缩进块的语句。</li>
<li>range()</li>
<li>while x&gt;0:&hellip;</li>
<li>break 退出循环</li>
<li>continue  跳过</li>
</ul>
<h3 id="dict和set-1">dict和set</h3>
<ul>
<li>
<p>dict  {&lsquo;Michael&rsquo;: 95, &lsquo;Bob&rsquo;: 75, &lsquo;Tracy&rsquo;: 85}</p>
<ul>
<li>类似map，键值对</li>
<li>判断key是否存在
- ’a‘ in dict 通过in
- d.get(&lsquo;Thomas&rsquo;, -1)</li>
<li>pop(key) 删除指定键值对</li>
</ul>
</li>
<li>
<p>set 只包含key的集合{1,2，3}</p>
<ul>
<li>add()</li>
<li>remove()</li>
<li>两个set 可以做&amp; |</li>
</ul>
</li>
</ul>
<p>###函数</p>
<ul>
<li>
<p>abs()</p>
</li>
<li>
<p>max()</p>
</li>
<li>
<p>数据类型转换</p>
<ul>
<li>int(&lsquo;123&rsquo;)</li>
<li>float()</li>
<li>str()</li>
<li>bool()</li>
</ul>
</li>
<li>
<p>定义函数 def my_function(x):&hellip;</p>
</li>
<li>
<p>导入函数 from demo1 import my_function</p>
</li>
<li>
<p>pass 什么都不做</p>
</li>
<li>
<p>isinstance(x,(int, float))</p>
</li>
<li>
<p>参数</p>
<ul>
<li>位置参数</li>
<li>默认参数 def power(x, n=2):..</li>
<li>可变参数 def calc(*number):&hellip;return sum 在函数调用时自动组装为一个tuple</li>
<li>关键字参数 def person(name,age,**kw):&hellip;传入任意dict</li>
<li>命名关键字参数 def person(name,age,*,city,job):&hellip; 调用时必须写key参数名</li>
</ul>
</li>
<li>
<p>递归函数</p>
<ul>
<li>
<p>尾递归优化（没做优化，也没啥用，依然可能栈溢出）</p>
<pre><code> def fact(n):
   return fact_iter(n,1)

 def fact_iter(num,product):
   if num == 1:
       retutn 1
   return fact_iter(num-1,num*product)
</code></pre>
</li>
</ul>
</li>
</ul>
<p>###特性</p>
<ul>
<li>
<p>切片</p>
<ul>
<li>L[0:10] 取0-9，0可以省略，指取10个</li>
<li>L[-10:] 取倒数10个元素</li>
<li>L[::5] 所有数每5个取一个</li>
<li>list、tuple、str 都可以用切片操作</li>
</ul>
</li>
<li>
<p>迭代</p>
<ul>
<li>list、tuple 直接for&hellip;in..</li>
<li>dict
<ul>
<li>for key in d</li>
<li>for value in d.values()</li>
<li>for k,v in d.items()</li>
</ul>
</li>
<li>字符串 for ch in &lsquo;ABC&rsquo;:</li>
<li>list 使用下标循环 for i,value in enumerate([&lsquo;A&rsquo;,&lsquo;B&rsquo;,&lsquo;C&rsquo;]):</li>
</ul>
</li>
<li>
<p>列表生成式</p>
<ul>
<li>创建list的生成式</li>
<li>[x*x for x in range(1,11) if x % 2 ==0]</li>
<li>还可以两层循环 [m + n for m in &lsquo;ABC for n in &lsquo;XYZ&rsquo;]</li>
<li>也可以使用两个变量 [k +&rsquo;=&rsquo;+v for k,v in d.items()]</li>
</ul>
</li>
<li>
<p>生成器</p>
<ul>
<li>generator 一边循环一边计算的机制</li>
<li>创建方法：
<ul>
<li>
<p>g = (x * x for x in range(10)) 把一个列表生成式的[]改成()</p>
</li>
<li>
<p>next（g) 获得下一个返回值</p>
</li>
<li>
<p>for n in g:&hellip; 可以迭代循环generator</p>
</li>
<li>
<p>推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现</p>
<pre><code>  def fib(max) :
      n,a,b = 0,0,1
      while n&lt; max:
          yield b
          a,b = b,a+b
          n = n + 1
      return 'done'
</code></pre>
</li>
<li>
<p>yield 使函数变成一个generator</p>
</li>
<li>
<p>for 循环调用generator时想拿到返回值必须捕获StopIteration</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>迭代器</p>
<ul>
<li>Iterable 可直接作用for循环的对象 list、tuple、dict、set、str、generator</li>
<li>Iterator 迭代器，可以被next()函数调用并不断返回下一个值的对象</li>
<li>isinstance</li>
<li>from collections import Iterator</li>
</ul>
</li>
</ul>
<h3 id="函数式编程-1">函数式编程</h3>
<ul>
<li>
<p>高阶函数 一个函数可以接受另一个函数作为参数</p>
<pre><code>  def add(a,b,f):
      return  f(a) +ｆ（ｂ）
</code></pre>
<ul>
<li>
<p><strong>map()</strong> 接收函数和Iterable，返回Iterator</p>
<pre><code>   list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
</code></pre>
</li>
<li>
<p>**reduce()**接受函数和序列，函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</p>
<pre><code>  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
</li>
<li>
<p><strong>filter()</strong> 过滤序列</p>
<pre><code>  list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
</code></pre>
</li>
<li>
<p><strong>sorted()</strong> 可以对list排序，可以接收一个key函数来实现自定义的排序</p>
<pre><code>   sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
</code></pre>
</li>
</ul>
</li>
<li>
<p>返回函数</p>
<ul>
<li>
<p>高阶函数除了可以接收函数作为参数还可以将函数作为结果值返回</p>
<pre><code>  def lazy_sum(*args):
      def sum():
          ax = 0
          for n in args:
              ax = ax + n
          return ax
      return sum
  f #返回函数
  f() #调用函数
</code></pre>
</li>
<li>
<p>返回函数中不要引用任何可能会变化的变量。</p>
</li>
</ul>
</li>
<li>
<p>匿名函数 lambda x ： x*x</p>
</li>
<li>
<p>装饰器 decorator</p>
<ul>
<li>
<p>函数也是一个对象 也有属性 f.<em>name</em>  拿到f函数的名字</p>
</li>
<li>
<p>decorator就是一个返回函数的高阶函数</p>
<pre><code>  import functools

  def log(func):
      #把原始函数的__name__等属性复制到wrapper()函数
      @functools.wrap(func) 

      def wrapper(*args, **kw):
          print('call %s():' % func.__name__)
          return func(*args, **kw)
      return wrapper

  @log
  def now():
          print('2015-3-25')

  把@log放到now()函数的定义处，相当于执行了语句：now = log(now)
</code></pre>
</li>
</ul>
</li>
<li>
<p>偏函数</p>
<pre><code>      import functools
      int2 = functools.partial(int ,base = 2)
      int2('1010101')  #85
</code></pre>
</li>
</ul>
<p>###模块</p>
<pre><code>    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    
    ' a test module '
    
    __author__ = 'Michael Liao'
    
    import sys
    
    def test():
        args = sys.argv
        if len(args)==1:
                print('Hello, world!')
        elif len(args)==2:
            print('Hello, %s!' % args[1])
        else:
            print('Too many arguments!')
    
    if __name__=='__main__':
        test()
</code></pre>
<ul>
<li>
<p>import sys 导入模块</p>
</li>
<li>
<p>sys模块有一个argv变量，用list存储了命令行的所有参数</p>
</li>
<li>
<p>命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，一般用于测试</p>
</li>
<li>
<p>作用域</p>
<ul>
<li>正常函数变量名可以直接引用</li>
<li>_xxx_特殊变量名</li>
<li>_xxx和__xxx非公开的函数private</li>
</ul>
</li>
<li>
<p>安装模块 pip install Pillow</p>
</li>
<li>
<p>模块搜索路径 存放在sys模块的path变量中</p>
<ul>
<li>一是直接修改sys.path，添加要搜索的目录： sys.path.append(&rsquo;/Users/michael/my_py_scripts&rsquo;)</li>
<li>第二种方法是设置环境变量PYTHONPATH</li>
</ul>
</li>
</ul>
<h3 id="面向对象编程-1">面向对象编程</h3>
<pre><code> class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))
</code></pre>
<ul>
<li>
<p>创建实例直接 bart = Student()</p>
</li>
<li>
<p>__name 双下划线 变成了私有变量，实质是Python解释器对外改成了_Student__name</p>
</li>
<li>
<p>继承</p>
<pre><code>   class Dog（Animal）:
      def run(self):
          print(Dog is running...)
      def eat(self):
          print(Dog is eating...)
</code></pre>
</li>
<li>
<p>获取对象信息</p>
<ul>
<li>type()</li>
<li>isinstance(&lsquo;a&rsquo;,str)</li>
<li>dir() 获得对象的所有属性和方法</li>
<li>操作状态 getattr() 、setattr()、hasattr()</li>
</ul>
</li>
<li>
<p>类属性 相当于成员变量</p>
</li>
</ul>
<p>###面向对象高级编程</p>
<ul>
<li>
<p>限制实例的变量</p>
<pre><code>  class Student(object):
      __slot__ = ('name','age') # 用元组定义只允许绑定的属性
</code></pre>
</li>
<li>
<p>为了检查参数使用</p>
<pre><code>  class Student(Object):

      @property
      def score(self):
          return self._score

      @score.setter
      def score(self,value):
          if not isinstance(value,int):
              raise ValueError('must be integer')
          if value &lt; 0 or value &gt; 100:
              raise ValueError('more than..')
          self._score = value                
</code></pre>
<ul>
<li>@property      把getter方法变成了属性</li>
<li>@score.setter        @property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值</li>
<li>只定义getter方法@property，不定义setter方法就是一个只读属性：</li>
</ul>
</li>
<li>
<p>多重继承</p>
<ul>
<li>class Dog（Mammal，Runnable）</li>
<li>让某个类除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn</li>
</ul>
</li>
<li>
<p>定制类</p>
<pre><code>  __str__    #print 返回自定义字符串，直接敲变量本质调用__repr__
  __iter__ #返回一个迭代对象 
  __getitem__ # 像list一样可以按下标访问数列的任意一项
  __getattr__  #在没有找到属性的情况下，才调用__getattr__
  __call__     #可以对实例直接调用，callable()判断是否可调用
</code></pre>
</li>
<li>
<p>枚举类</p>
<pre><code>  from enum import Enum
  Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

  for name,member in Month.__member__.items():
      print(name,'==&gt;',member,',',member.value)

  #value属性则是自动赋给成员的int常量，默认从1开始计数。
</code></pre>
</li>
</ul>
<hr>
<pre><code>    from enum import Enum, unique
    
    @unique                  #检查没有重复值
    class Weekday(Enum):    #从Enum派生出自定义类
        Sun = 0 # Sun的value被设定为0
        Mon = 1
        Tue = 2
        Wed = 3
        Thu = 4
        Fri = 5
        Sat = 6
</code></pre>
<ul>
<li>元类 metaclass
<ul>
<li>
<p>type() 既可以返回对象的类型，又可以创建出新的类型</p>
<pre><code>  def fn(self,name='world'):
      print('Hello,%s!'%name)

  Hello = type('Hello',(object,),dict(hello=fn)) # 创建Hello.class
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="错误处理-1">错误处理</h3>
<pre><code>	try:
    	10 / 0
	except ZeroDivisionError:
    	raise ValueError('input error!')
</code></pre>
<ul>
<li>
<p>断言</p>
<pre><code>  def foo(s):
      n = int(s)
      assert n != 0, 'n is zero!'
      return 10 / n

  def main():
      foo('0')	
</code></pre>
<ul>
<li>
<p>用-O参数来关闭assert:</p>
<pre><code>  python3 -O err.py	
</code></pre>
</li>
</ul>
</li>
<li>
<p>logging</p>
<pre><code>  import logging
  logging.basicConfig(level=logging.INFO)

  s = '0'
  n = int(s)
  logging.info('n = %d' % n)
  print(10 / n)
</code></pre>
</li>
</ul>
<p>###读写文件</p>
<ul>
<li>
<p>读</p>
<pre><code>  with open('path','rb') as f :
  	print(f.read())

  #二进制 编码 编码错误
   f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')
</code></pre>
</li>
<li>
<p>写</p>
</li>
</ul>
<blockquote>
</blockquote>
<pre><code>	with open('/Users/michael/test.txt', 'w') as f:
	    f.write('Hello, world!')		
</code></pre>
<ul>
<li>
<p>IO流</p>
<ul>
<li>StringIO</li>
<li>BytesIO</li>
<li></li>
</ul>
</li>
<li>
<p>参考：
<a href="http://www.liaoxuefeng.com/">http://www.liaoxuefeng.com/</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>git常用规范</title>
      <link>https://justinbetter.github.io/2019/07/15/git%E5%B8%B8%E7%94%A8%E8%A7%84%E8%8C%83/</link>
      <pubDate>Mon, 15 Jul 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2019/07/15/git%E5%B8%B8%E7%94%A8%E8%A7%84%E8%8C%83/</guid>
      <description>&lt;h1 id=&#34;分支规范&#34;&gt;分支规范&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;- 分支规范
    1. 分支命名规范：
        - master: 主线分支
        - feature/xxxx: 功能需求开发分支
        - hotfix/xxxx: bug 修复分支
        - refactor/xxxx: 重构分支
    2. 默认从主线分支 checkout 出功能需求 or bug 修复分支
    3. 分支合并需要写清本次开发的内容点
- Commit Message 规范
    1. 命名规则：func[(main)]: done something
        - 其中 `[ ]` 中的内容可以省略
    2. func 规则：
        1. feat: 新功能开发
        2. fix: bug 修复
        3. refactor: 不影响现有功能的重构
        4. test: 添加测试
        5. chore: 构建工具改动
        6. style: 格式改动
    3. 冒号（英文冒号，并空一格）后面写上这次 commit 提交的内容，最好一个小功能点一次提交
    4. 禁止类似 `update` 这样无意义的提交！


查看当前url
git remote -v
git remote set-url origin [url]

git remote rm origin
git remote add origin [url]




git config user.name &amp;quot;xxx&amp;quot;

git push origin --tags 推送tag

回退版本
git reset --hard 版本号  
git push -f -u origin master

查看项目的分支们(包括本地和远程) 
命令行 : $ git branch -a     例如，$ git branch -a 

删除本地分支 
命令行 : $ git branch -d &amp;lt;BranchName&amp;gt;

ssh
ssh-keygen -t rsa -C &amp;quot;xxx@xxx.com&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;</description>
      <content:encoded><![CDATA[<h1 id="分支规范">分支规范</h1>
<pre><code>- 分支规范
    1. 分支命名规范：
        - master: 主线分支
        - feature/xxxx: 功能需求开发分支
        - hotfix/xxxx: bug 修复分支
        - refactor/xxxx: 重构分支
    2. 默认从主线分支 checkout 出功能需求 or bug 修复分支
    3. 分支合并需要写清本次开发的内容点
- Commit Message 规范
    1. 命名规则：func[(main)]: done something
        - 其中 `[ ]` 中的内容可以省略
    2. func 规则：
        1. feat: 新功能开发
        2. fix: bug 修复
        3. refactor: 不影响现有功能的重构
        4. test: 添加测试
        5. chore: 构建工具改动
        6. style: 格式改动
    3. 冒号（英文冒号，并空一格）后面写上这次 commit 提交的内容，最好一个小功能点一次提交
    4. 禁止类似 `update` 这样无意义的提交！


查看当前url
git remote -v
git remote set-url origin [url]

git remote rm origin
git remote add origin [url]




git config user.name &quot;xxx&quot;

git push origin --tags 推送tag

回退版本
git reset --hard 版本号  
git push -f -u origin master

查看项目的分支们(包括本地和远程) 
命令行 : $ git branch -a     例如，$ git branch -a 

删除本地分支 
命令行 : $ git branch -d &lt;BranchName&gt;

ssh
ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot; 
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux笔记</title>
      <link>https://justinbetter.github.io/2019/06/15/linux%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 15 Jun 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2019/06/15/linux%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;帮助手册命令-man&#34;&gt;帮助手册命令 man&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;man命令：可以通过一些参数，快速查询linux帮助手册，并且格式化显示。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##Linux 下修改 root 密码方法
passwd root&lt;/p&gt;
&lt;h2 id=&#34;权限&#34;&gt;权限&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;chgrp ：改变文件所属群组
chown -R：改变文件拥有者
chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性	
su - user1  切换身份user1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查看服务&#34;&gt;查看服务&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt; /etc/services 
 /etc/init.d/  启动脚本处	
 /etc/* ：各服务各自的配置文件
 service --status-all 查看所有服务
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常用目录&#34;&gt;常用目录&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/etc                主要配置文件
/bin                常用执行文件
/sbin               重要的系统执行文件
/dev                存放设备文件
/dev/null           垃圾桶
/home               用户目录
/media /mnt         挂载外部装置
/opt                第三方协议软件 习惯放/usr/local
/proc               虚拟文件，存放内存数据:系统cpu、网络..

/ (root, 根目录)：   与开机系统有关；
/usr (unix software resource)：与软件安装/执行有关；
/usr/local/        自己下载的软件安装目录
/var (variable)：  与系统运作过程有关的常态性变动的文件：缓存、log等。

/etc/issue         配置开机画面显示
/etc/motd          配置登录显示
/etc/ssh/sshd_config ssh配置
~/.ssh/authorized_keys 加入ssh公钥,免密码登录
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;英文全称&#34;&gt;英文全称&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;df: Disk free  空余硬盘
du: Disk usage 硬盘使用率
su：Swith user  切换用户，切换到root用户
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;du -s * | sort -nr | head 选出排在前面的10个 文件夹大小排序
ctrl+r 搜索历史记录
lsb_release -a    系统版本
双击tab            获取所有可能的命令,极其方便!
ls -alh           list所有文件包括隐藏文件
ls -l --sort=time -r 升序展示
set               获取所有变量,包含bash接口配置相关
echo $$           当前shell的PID
echo $?           返回上个命令的执行结果
env/export        显示所有环境变量
echo $PATH        显示环境变量中的PATH
PATH=$PATH:/home/dmtsai/bin  增加目录到变量
export var1 	  使其变为环境变量,可以让子shell使用

echo $(uname -r)  显示系统版本
uname -a          显示系统架构
grub2-editenv list 查看默认内核
    grub2-set-default &amp;quot;CentOS Linux (3.10.0-327.el7.x86_64) 7 (Core)&amp;quot;


设置变量           name=justin
取消变量           unset name
命令中使用其他命令   $(command)
创建目录：          mkdir /tmp/chapter7_1
修改属性：          chown -R dmtsai:users /tmp/chapter7_1
修改权限：          chmod -R 755 /tmp/chapter7_1
//SUID/SGID/SBIT 权限配置--&amp;gt; 要有x权限   
		4 为 SUID       暂时将具有该程序拥有者 (owner) 的权限；
		2 为 SGID       暂时获得得该程序群组的支持
		1 为 SBIT       wx权限下,仅有自己与 root 才有权力删除该文件
		
观察文件类型：       file
搜索命令完整路径：    which
搜索文件： 
	whereis       whereis 与 locate 是利用数据库来搜寻数据
	updatedb      手动更新数据库
	find          强大的搜寻命令，但时间花用的很大！ 因为 find 是直接搜寻硬盘
		find / -perm /6000   查询具有suid、sgid的文件

df -h             获取目前挂载的设备，整体磁盘使用量
du -sh            获取文件所占容量
	bug 卡住了
	strace df -h
	systemctl restart proc-sys-fs-binfmt_misc.automount


dumpe2fs          查询每个区段与 superblock 的信息
ln -s /etc/crontab crontab2 创建符号链接，类似windows 的快捷方式


read -p &amp;quot;Please keyin your name: &amp;quot; -t 30 named  读取键盘输入
declare                   声明变量
ulimit -a                 显示当前用户的数据限制值
last                      显示登陆者信息
alias                     显示当前所有的命令别名,设置别名
unalias                   取消别名
history                   使用过的命令历史
type -a                   获取命令搜寻顺序
!comand                   运行最近命令开头为command的命令
source/.                  读入环境配置文件，可以直接在父程序运行脚本
chattr (配置文件隐藏属性)
lsattr (显示文件隐藏属性)
pwd 显示当前目录
		
//输入输出
标准输入　　(stdin) ：代码为 0 ，使用 &amp;lt; 或 &amp;lt;&amp;lt; ；
标准输出　　(stdout)：代码为 1 ，使用 &amp;gt; 或 &amp;gt;&amp;gt; ；
标准错误输出(stderr)：代码为 2 ，使用 2&amp;gt; 或 2&amp;gt;&amp;gt; ；
重定向操作符（&amp;amp;&amp;gt;）将标准输出和错误输出同时送到同一文件

//pipe
|grep|cut|sort|uniq|wc
|tee test.txt            双向重导向,分送到文件去与屏幕stdout,可以让下个命令继续使用      
 - 减号                   可以取用前一个命令的 stdout

	//正则
find .| xargs grep -ri &amp;quot;18616504954&amp;quot; -l  目录下的所有文件中查找字符串,并且只打印出含有该字符串的文件名

grep &#39;^ha&#39; test.txt -n    单引号中使用正则
sed                       将数据 standard input 进行取代、删除、新增、撷取特定行等
						  e.g: nl test.txt |sed &#39;2,3d&#39;
						       sed &#39;s/要被取代的字串/新的字串/g&#39;

printf                    格式化输出
awk &#39;条件类型1{动作1} 条件类型2{动作2} ...&#39; filename   处理数据
	
		$NF代表：最后一个Field(列)


diff/cmp                  比对两个文件
test                      检查工具, 判断文件属性等
tail -cf 			      循环读取文件末尾日志   

less test.log  打开文件，按大写实时刷新
		
		- F 实时刷新
		- N 显示行号

dig xxx +short            查看域名                 

//切换

&amp;amp;                       直接将命令丢到背景中『运行』的 &amp;amp;
[ctrl]+z                 将『目前』的工作丢到背景中『暂停
jobs                    观察目前的背景工作状态： jobs
				用jobs查看进程的jobnumber，然后用命令：kill %n 来结束。
			
fg                      将背景工作拿到前景来处理：fg
bg                      让工作在背景下的状态变成运行中： bg
kill                    管理背景当中的工作： kill
		 killall -9 httpd       强制终止所有以 httpd 启动的程序
		 killall -1 syslogd       给予 syslogd 这个命令启动的 PID 一个 SIGHUP 的讯号
	     killall -i -9 bash      依次询问每个 bash 程序是否需要被终止运行！

//服务管理
 service --status-all  显示出目前系统上面所有服务的运行状态
 chkconfig： 管理系统服务默认启动启动与否
			 chkconfig --list [服务名称]
			 chkconfig [--level [0123456]] [服务名称] [on|off]		 
			  *启动 Linux 系统时，可以进入不同的模式喔，这模式我们称为运行等级, 正常的运行等级有两个，一个是具有 X 窗口接口的 run level 5 ，另一个则是纯文本界面的 run level 3。* 

logrotate [-vf] logfile       显示 logrotate 运行过程

tar czvf my.tar.gz dir1 单个目录压缩打包 
	tar czvf shell30.tar.gz  /usr/local/system/bin
tar xzvf my.tar.gz 解包至当前目录

ls -l | grep &amp;quot;^-&amp;quot; | wc -l 统计文件个数
	
curl -H &amp;quot;Sign:#f93Uc31K24()_@&amp;quot; -d &amp;quot;fatherId=10155&amp;quot; http://dbt.lego.iqiyi.com/api/program/find
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;文件系统&#34;&gt;文件系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux 的正统文件系统则为 Ext2 (Linux second extended file system, ext2fs)这一个。此外，在默认的情况下，windows 操作系统是不会认识 Linux 的 Ext2 的。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="帮助手册命令-man">帮助手册命令 man</h2>
<pre><code>man命令：可以通过一些参数，快速查询linux帮助手册，并且格式化显示。
</code></pre>
<p>##Linux 下修改 root 密码方法
passwd root</p>
<h2 id="权限">权限</h2>
<pre><code>chgrp ：改变文件所属群组
chown -R：改变文件拥有者
chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性	
su - user1  切换身份user1
</code></pre>
<h2 id="查看服务">查看服务</h2>
<pre><code> /etc/services 
 /etc/init.d/  启动脚本处	
 /etc/* ：各服务各自的配置文件
 service --status-all 查看所有服务
</code></pre>
<h2 id="常用目录">常用目录</h2>
<pre><code>/etc                主要配置文件
/bin                常用执行文件
/sbin               重要的系统执行文件
/dev                存放设备文件
/dev/null           垃圾桶
/home               用户目录
/media /mnt         挂载外部装置
/opt                第三方协议软件 习惯放/usr/local
/proc               虚拟文件，存放内存数据:系统cpu、网络..

/ (root, 根目录)：   与开机系统有关；
/usr (unix software resource)：与软件安装/执行有关；
/usr/local/        自己下载的软件安装目录
/var (variable)：  与系统运作过程有关的常态性变动的文件：缓存、log等。

/etc/issue         配置开机画面显示
/etc/motd          配置登录显示
/etc/ssh/sshd_config ssh配置
~/.ssh/authorized_keys 加入ssh公钥,免密码登录
</code></pre>
<h2 id="英文全称">英文全称</h2>
<pre><code>df: Disk free  空余硬盘
du: Disk usage 硬盘使用率
su：Swith user  切换用户，切换到root用户
</code></pre>
<h2 id="常用命令">常用命令</h2>
<pre><code>du -s * | sort -nr | head 选出排在前面的10个 文件夹大小排序
ctrl+r 搜索历史记录
lsb_release -a    系统版本
双击tab            获取所有可能的命令,极其方便!
ls -alh           list所有文件包括隐藏文件
ls -l --sort=time -r 升序展示
set               获取所有变量,包含bash接口配置相关
echo $$           当前shell的PID
echo $?           返回上个命令的执行结果
env/export        显示所有环境变量
echo $PATH        显示环境变量中的PATH
PATH=$PATH:/home/dmtsai/bin  增加目录到变量
export var1 	  使其变为环境变量,可以让子shell使用

echo $(uname -r)  显示系统版本
uname -a          显示系统架构
grub2-editenv list 查看默认内核
    grub2-set-default &quot;CentOS Linux (3.10.0-327.el7.x86_64) 7 (Core)&quot;


设置变量           name=justin
取消变量           unset name
命令中使用其他命令   $(command)
创建目录：          mkdir /tmp/chapter7_1
修改属性：          chown -R dmtsai:users /tmp/chapter7_1
修改权限：          chmod -R 755 /tmp/chapter7_1
//SUID/SGID/SBIT 权限配置--&gt; 要有x权限   
		4 为 SUID       暂时将具有该程序拥有者 (owner) 的权限；
		2 为 SGID       暂时获得得该程序群组的支持
		1 为 SBIT       wx权限下,仅有自己与 root 才有权力删除该文件
		
观察文件类型：       file
搜索命令完整路径：    which
搜索文件： 
	whereis       whereis 与 locate 是利用数据库来搜寻数据
	updatedb      手动更新数据库
	find          强大的搜寻命令，但时间花用的很大！ 因为 find 是直接搜寻硬盘
		find / -perm /6000   查询具有suid、sgid的文件

df -h             获取目前挂载的设备，整体磁盘使用量
du -sh            获取文件所占容量
	bug 卡住了
	strace df -h
	systemctl restart proc-sys-fs-binfmt_misc.automount


dumpe2fs          查询每个区段与 superblock 的信息
ln -s /etc/crontab crontab2 创建符号链接，类似windows 的快捷方式


read -p &quot;Please keyin your name: &quot; -t 30 named  读取键盘输入
declare                   声明变量
ulimit -a                 显示当前用户的数据限制值
last                      显示登陆者信息
alias                     显示当前所有的命令别名,设置别名
unalias                   取消别名
history                   使用过的命令历史
type -a                   获取命令搜寻顺序
!comand                   运行最近命令开头为command的命令
source/.                  读入环境配置文件，可以直接在父程序运行脚本
chattr (配置文件隐藏属性)
lsattr (显示文件隐藏属性)
pwd 显示当前目录
		
//输入输出
标准输入　　(stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；
标准输出　　(stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；
标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；
重定向操作符（&amp;&gt;）将标准输出和错误输出同时送到同一文件

//pipe
|grep|cut|sort|uniq|wc
|tee test.txt            双向重导向,分送到文件去与屏幕stdout,可以让下个命令继续使用      
 - 减号                   可以取用前一个命令的 stdout

	//正则
find .| xargs grep -ri &quot;18616504954&quot; -l  目录下的所有文件中查找字符串,并且只打印出含有该字符串的文件名

grep '^ha' test.txt -n    单引号中使用正则
sed                       将数据 standard input 进行取代、删除、新增、撷取特定行等
						  e.g: nl test.txt |sed '2,3d'
						       sed 's/要被取代的字串/新的字串/g'

printf                    格式化输出
awk '条件类型1{动作1} 条件类型2{动作2} ...' filename   处理数据
	
		$NF代表：最后一个Field(列)


diff/cmp                  比对两个文件
test                      检查工具, 判断文件属性等
tail -cf 			      循环读取文件末尾日志   

less test.log  打开文件，按大写实时刷新
		
		- F 实时刷新
		- N 显示行号

dig xxx +short            查看域名                 

//切换

&amp;                       直接将命令丢到背景中『运行』的 &amp;
[ctrl]+z                 将『目前』的工作丢到背景中『暂停
jobs                    观察目前的背景工作状态： jobs
				用jobs查看进程的jobnumber，然后用命令：kill %n 来结束。
			
fg                      将背景工作拿到前景来处理：fg
bg                      让工作在背景下的状态变成运行中： bg
kill                    管理背景当中的工作： kill
		 killall -9 httpd       强制终止所有以 httpd 启动的程序
		 killall -1 syslogd       给予 syslogd 这个命令启动的 PID 一个 SIGHUP 的讯号
	     killall -i -9 bash      依次询问每个 bash 程序是否需要被终止运行！

//服务管理
 service --status-all  显示出目前系统上面所有服务的运行状态
 chkconfig： 管理系统服务默认启动启动与否
			 chkconfig --list [服务名称]
			 chkconfig [--level [0123456]] [服务名称] [on|off]		 
			  *启动 Linux 系统时，可以进入不同的模式喔，这模式我们称为运行等级, 正常的运行等级有两个，一个是具有 X 窗口接口的 run level 5 ，另一个则是纯文本界面的 run level 3。* 

logrotate [-vf] logfile       显示 logrotate 运行过程

tar czvf my.tar.gz dir1 单个目录压缩打包 
	tar czvf shell30.tar.gz  /usr/local/system/bin
tar xzvf my.tar.gz 解包至当前目录

ls -l | grep &quot;^-&quot; | wc -l 统计文件个数
	
curl -H &quot;Sign:#f93Uc31K24()_@&quot; -d &quot;fatherId=10155&quot; http://dbt.lego.iqiyi.com/api/program/find
</code></pre>
<h2 id="文件系统">文件系统</h2>
<ul>
<li>
<p>Linux 的正统文件系统则为 Ext2 (Linux second extended file system, ext2fs)这一个。此外，在默认的情况下，windows 操作系统是不会认识 Linux 的 Ext2 的。</p>
</li>
<li>
<p>inode 表 每个文件都仅会占用一个 inode 而已,记录文件的属性及该文件实际数据是放置在哪几号 block 内；</p>
</li>
<li>
<p>data block是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已</p>
</li>
<li>
<p>一般来说，我们将 inode table 与 data block 称为数据存放区域，至于其他例如 superblock、 block bitmap 与 inode bitmap 等区段就被称为 metadata (中介数据) 啰，因为 superblock, inode bitmap 及 block bitmap 的数据是经常变动的，每次新增、移除、编辑时都可能会影响到这三个部分的数据</p>
</li>
</ul>
<h2 id="swap">Swap</h2>
<ul>
<li>swap 的功能就是在应付物理内存不足的情况下所造成的内存延伸记录的功能。</li>
<li>当物理内存不够时，则某些在内存当中所占的程序会暂时被移动到 swap 当中，让物理内存可以被需要的程序来使用。另外，如果你的主机支持电源管理模式， 也就是说，你的 Linux 主机系统可以进入『休眠』模式的话，那么， 运行当中的程序状态则会被纪录到 swap 去，以作为『唤醒』主机的状态依据！ 另外，有某些程序在运行时，本来就会利用 swap 的特性来存放一些数据段， 所以， swap 来是需要创建的！只是不需要太大！</li>
</ul>
<h2 id="vi">vi</h2>
<pre><code>全部复制：按esc键后，先按gg，然后ggyG
：set number 显示行号
0/Home 移动到行前
$/End  移动到行尾
[Ctrl] + [f] 向下移动一页
[Ctrl] + [b] 向上移动一页
G	移动到这个档案的最后一行
gg/1G  移动到第一行

u 撤销
o 当前位置下创建一行
O 当前位置上创建一行
dd 删除光标所在行
x 删除光标后字符
X 删除光标前字符
yy 复制当前行
p  粘贴
J 当前行连接下一行

v 字符选择
V 行选择
ctrl+v 区块选择
y 复制选择
d 删除选择

/word  搜寻字符串	，光标之上
?word  搜寻字符串，光标之下
加入`\c`表示大小写不敏感查找，`\C`表示大小写敏感查找
搜索A与B /.*A\&amp;.*B

n      继续搜索
N      反向搜索

多行编辑
ctrl+v j按多次 esc 

vim 后面同时接好几个档案可同时开启 
:n	编辑下一个档案
:N	编辑上一个档案
:files	列出目前这个 vim 的开启的所有档案

//多窗口
:sp [filename] 开启一个新窗口
[ctrl]+w 放开+↓	 移到下方窗口
[ctrl]+w 放开+↑	 移到上方窗口	
</code></pre>
<h2 id="bash">Bash</h2>
<pre><code>/etc/shells 	查看可用的shell
/etc/passwd     查看不同用户取得的默认shell
/.bash_history  这个隐藏目录保存了使用的命令历史
\+[Enter]       避免命令太长,多行使用
</code></pre>
<h2 id="scripts">scripts</h2>
<ul>
<li>
<p>date +%Y%m%d 获取今天日期</p>
<pre><code>   echo $(date '+%Y-%m-%d %H:%M:%S') &gt;&gt; $LOG_DIR/$LOG_NAME
</code></pre>
</li>
<li>
<p>script 的运行方式差异 (source, sh script, ./script)</p>
</li>
<li>
<p>善用判断式</p>
<ul>
<li>
<p>test</p>
</li>
<li>
<p>[ &ldquo;VBird Tsai&rdquo; == &ldquo;VBird&rdquo; ]</p>
<pre><code>  -e	该『档名』是否存在？(常用)
  -f 该『档名』是否存在且为文件(file)？(常用)
  -d	该『档名』是否存在且为目录(directory)？(常用)
  -a	(and)两状况同时成立。
  -o	(or)两状况任何一个成立。
  !	反相状态，如 test ! -x file ，当 file 不具有 x 时，回传 true

  -eq	两数值相等 (equal)
  -ne	两数值不等 (not equal)
  -gt	n1 大於 n2 (greater than)
  -lt	n1 小於 n2 (less than)
  -ge	n1 大於等於 n2 (greater than or equal)
  -le	n1 小於等於 n2 (less than or equal)	
  $# ：代表后接的参数『个数』
  ll ：代表『 &quot;$1c$2c$3c$4&quot; 』，其中 c 为分隔字节，默认为空白键， 所以本例中代表『 &quot;$1 $2 $3 $4&quot; 』之意。
  $!  Shell最后运行的后台Process的PID
</code></pre>
</li>
</ul>
</li>
<li>
<p>Shell script 的默认变量($0, $1&hellip;)</p>
<pre><code>  运行的脚本档名为 $0 这个变量，第一个接的参数就是 $1 啊
</code></pre>
</li>
<li>
<p>条件判断式</p>
<pre><code>  //单条件
  if [ 条件判断式 ]; then
  	当条件判断式成立时，可以进行的命令工作内容；
  fi  

  //多条件
  if [ 条件判断式一 ]; then
  	当条件判断式一成立时，可以进行的命令工作内容；
  elif [ 条件判断式二 ]; then
  	当条件判断式二成立时，可以进行的命令工作内容；
  else
  	当条件判断式一与二均不成立时，可以进行的命令工作内容；
  fi

  //case
  case  $变量名称 in   
    &quot;第一个变量内容&quot;)   
  	程序段
  	;;            
    &quot;第二个变量内容&quot;)
  	程序段
  	;;
    *)                  
  	不包含第一个变量内容与第二个变量内容的其他程序运行段
  	exit 1
  	;;
  esac     
</code></pre>
</li>
<li>
<p>循环</p>
<pre><code>  //满足条件才开始循环
  while [ condition ] 
  do            
  	程序段落
  done          

  //满足才结束
  until [ condition ]
  do
  	程序段落
  done

  //固定循环
  for var in con1 con2 con3 ...
  do
  	程序段
  done


  for (( 初始值; 限制值; 运行步阶 ))
  do
  	程序段
  done
</code></pre>
</li>
<li>
<p>函数</p>
<pre><code>  function fname() {
  	程序段
  }
</code></pre>
</li>
<li>
<p>检查语法错误</p>
<pre><code>   sh [-nvx] scripts.sh
</code></pre>
</li>
<li>
<p>sleep 3 #等3秒后执行下一条</p>
<pre><code>  # 語法：sleep NUMBER[SUFFIX]
  # SUFFIX 可以是:

  # s for seconds (the default)
  # m for minutes.
  # h for hours.
  # d for days.
</code></pre>
</li>
</ul>
<h2 id="账号管理">账号管理</h2>
<ul>
<li>
<p>uid和gid</p>
</li>
<li>
<p>涉及目录</p>
<pre><code>  /etc/passwd
  /etc/group
  /etc/shadow

  groups            查看所有支持的群组
  newgrp            有效群组的切换

  w/who             查询已登录的用户
  useradd           增加用户
  				参考:
  					/etc/default/useradd
  					/etc/login.defs
  					/etc/skel/*

  passwd  [用户]       修改用户密码
  				 echo &quot;abc543CC&quot; | passwd --stdin vbird2
  userdel -r home     删除用户
  id  [username]		            查询uid和gid
  groupadd
  groupmod                        group 相关参数的修改
  groupdel
  gpasswd                         群组管理员功能

  //acl 权限
  setfacl 
  getfacl filename

  //切换
  su - username 或 su -l username    切换用户
  su - -c &quot;命令串&quot;                   只运行一次root命令
  sudo                               以其他用户的身份运行命令( /etc/sudoers 内的用户才能够运行 sudo 这个命令)
  								e.g:
  								sudo -u sshd touch /tmp/mysshd
  visudo                           修改sudo配置

  //使用者对话
  write 使用者账号 [用户所在终端接口]   指定用户发送信息
  wall [message]                   对所有系统上面的用户传送简讯
</code></pre>
</li>
<li>
<p>PAM（Pluggable Authentication Modules 嵌入式授权模块）</p>
<ul>
<li>
<p>用户输入指令，呼叫 PAM 模块进行验证</p>
</li>
<li>
<p>PAM 模块会到 /etc/pam.d/ 找寻与程序 (passwd) 同名的配置文件</p>
</li>
<li>
<p>将验证结果 (成功、失败以及其他信息) 回传给用户指令程序</p>
</li>
<li>
<p>程序会根据 PAM 回传的结果决定下一个动作</p>
<p><img src="http://cn.linux.vbird.org/linux_basic/0410accountmanager_files/pam-2.gif" alt="控制标准"></p>
</li>
</ul>
</li>
<li>
<p>检查工具</p>
<pre><code>  pwck          检查用户配置信息
  grpck         检查用户组配置信息
  pwconv	  用户同步化将 /etc/passwd 内的账号与口令，移动到 /etc/shadow 
</code></pre>
</li>
</ul>
<h2 id="配额-quota">配额 Quota</h2>
<ul>
<li>
<p>限制 filesystem的 容量等</p>
</li>
<li>
<p>涉及目录,命令</p>
<pre><code>  /etc/fstab
  /etc/mtab                   文件系统是否支持配额
  /etc/warnquota.conf         警告信息设置
  quotaon -auvg               开启服务
  quotaoff                    关闭服务
  edquota                     编辑限制额度
  		-t      宽限时间
  		-u      用户
  		-g      用户组

  quota -uvs myuser &amp;&amp; quota -gvs myuser   查看配额
  repquota -auvs                查看整个文件系统的配额
</code></pre>
</li>
</ul>
<h2 id="raid-磁盘阵列">Raid 磁盘阵列</h2>
<ul>
<li>一个磁盘容量不够时,这种机制将多个较小的磁碟整合成为一个较大的磁碟装置, 便于使用</li>
<li>fdisk 命令</li>
</ul>
<h2 id="定时任务">定时任务</h2>
<ul>
<li>
<p>单次任务 at</p>
<pre><code>  /etc/init.d/atd restart
  chkconfig atd on           配置自动启动
  /var/spool/at/            日志记录
  /etc/at.allow              使用者配置
  /etc/at.deny               不能使用者配置

  at -c n       查询第n个任务
  at now + 5 minutes        创建任务
  batch 23:00 2009-3-17    系统空间时开始任务

  atq       查询所有单次任务
  atrm  n   将第n个任务删除
</code></pre>
</li>
<li>
<p>循环任务 crontab</p>
<pre><code>  /etc/crontab               系统任务
  /usr/bin/crontab         用户任务
  /etc/cron.allow
  /etc/cron.deny
  /var/spool/cron/[user]        任务创建日志记录
  /var/log/cron                      任务运行日志记录

  crontab -e              编辑任务
  		e.g: 59 23 1 5 * mail kiki &lt; /home/dmtsai/lover.txt
  crontab -l              查看所有任务
  run-parts               遍历目录中所有文件运行

  anacron               运行crontab 关机期间没有运行的任务


  minute   hour   day   month   week   command
  星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。

  逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”

  中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”

  正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。

  前面五个*号代表五个数字，数字的取值范围和含义如下：

  分钟　（0-59）  
  小時　（0-23）  
  日期　（1-31）  
  月份　（1-12）  
  星期　（0-6）//0代表星期天		
  5 * * * *每小时第5分钟执行  
  */5 * * * *每5分钟执行  
  0 2 * * * 每天凌晨2点执行
</code></pre>
</li>
</ul>
<h2 id="程序管理">程序管理</h2>
<pre><code> ps aux  &lt;==观察系统所有的程序数据
 ps -l   仅观察自己的 bash 相关程序：
 pstree  查看程序树,程序之间的关联性  ⇒ ps axjf
 
 free    观察内存使用情况
 top     查看程序运行状态 cpu,mem...
	 top -d 5 -p 13639
	 在 top 运行过程当中可以使用的按键命令：
	 	? ：显示在 top 当中可以输入的按键命令；
		P ：以 CPU 的使用资源排序显示；
		M ：以 Memory 的使用资源排序显示；
		N ：以 PID 来排序喔！
		T ：由该 Process 使用的 CPU 时间累积 (TIME+) 排序。
		k ：给予某个 PID 一个讯号  (signal)
		r ：给予某个 PID 重新制订一个 nice 值。
		q ：离开 top 软件的按键。
nice  新运行的命令即给予新的 nice 值
			nice -n -5 vi &amp;
renice [number] PID  已存在程序的 nice 重新调整
uname [-asrmpi] 查阅系统与核心相关资讯
uptime          观察系统启动时间与工作负载
netstat -tlunp   追踪网络或插槽档
vmstat          侦测系统资源变化
fuser -uv [filename]  查看文件使用者
lsof       读取程序使用的文件
		 lsof -u root -a -U
		 lsof +d /dev
pidof ：找出某支正在运行的程序的 PID

sestatus /getenforce  获取; 状态
semanage fcontext -l [file] 查询SELinux安全配置
		 
rpm -qa | grep ssh          可以看到系统中ssh安装包
rpm -ql openssh-3.5p1-6     查看该安装包安装信息(如安装路径,配置文件等)
ps -e | grep ssh            查看ssh服务有没有运行,如果有,可以看到类似以下内容:
</code></pre>
<h2 id="daemon-服务">daemon 服务</h2>
<ul>
<li>
<p>启动 daemon 的程序通常最末会加上一个 d ，例如 sshd, vsftpd, httpd 等</p>
<pre><code>  /etc/services
  /etc/init.d/* ：启动脚本放置处
  /etc/sysconfig/* ：各服务的初始化环境配置文件
  /etc/xinetd.conf, /etc/xinetd.d/* ：super daemon 配置文件
  /etc/* ：各服务各自的配置文件
  /var/lib/* ：各服务产生的数据库
  /var/run/* ：各服务的程序之 PID 记录处

   service --status-all  显示出目前系统上面所有服务的运行状态
</code></pre>
</li>
<li>
<p>配置demo</p>
<pre><code>  # 先针对对内的较为松散的限制来配置：
  service rsync
  {
          disable = no                        &lt;==要启动才行啊！
          bind            = 127.0.0.1         &lt;==服务绑在这个接口上！
          only_from       = 127.0.0.0/8       &lt;==只开放这个网域的来源登陆
          no_access       = 127.0.0.{100,200} &lt;==限制这两个不可登陆
          instances       = UNLIMITED         &lt;==取代 /etc/xinetd.conf 的配置值
          socket_type     = stream            &lt;==底下的配置则保留
          wait            = no
          user            = root
          server          = /usr/bin/rsync
          server_args     = --daemon
          log_on_failure  += USERID
  }

  # 再针对外部的联机来进行限制呢！
  service rsync
  {
          disable = no
          bind            = 192.168.1.100
          only_from       = 140.116.0.0/16
          only_from      += .edu.tw           &lt;==因为累加，所以利用 += 配置
          access_times    = 01:00-9:00 20:00-23:59 &lt;==时间有两时段，有空格隔开
          instances       = 10                &lt;==只有 10 条联机
          socket_type     = stream
          wait            = no
          user            = root
          server          = /usr/bin/rsync
          server_args     = --daemon
          log_on_failure  += USERID
  }		
</code></pre>
</li>
</ul>
<h2 id="防火墙">防火墙</h2>
<ul>
<li>
<p>涉及</p>
<pre><code>   /etc/hosts.{allow,deny}   进行类似防火墙的抵挡机制
</code></pre>
</li>
</ul>
<h2 id="log">log</h2>
<ul>
<li>
<p>设计目录</p>
<pre><code>  /etc/syslog.conf
</code></pre>
</li>
</ul>
<h2 id="linux-启动">Linux 启动</h2>
<ul>
<li>
<p>Loader 的最主要功能是要认识操作系统的文件格式并据以加载核心到主内存中去运行</p>
<pre><code>   /etc/inittab
   /etc/rc.d/rc.sysinit     init 处理系统初始化流程 
   /etc/sysconfig/         启动过程中存放的默认配置档
   /etc/rc.d/rc N           不同的 run level 服务启动的各个 shell script 
   /etc/rc.d/rc.local 		 自定义启动shell script

   runlevel                目前的 run level
  	  init 3                   将目前的 runlevel 切换成为 3 
  	 『 init 0 』就能够关机， 而『 init 6 』就能够重新启动
</code></pre>
</li>
<li>
<p>核心模块</p>
<pre><code>  核心： /boot/vmlinuz 或 /boot/vmlinuz-version；
  核心解压缩所需 RAM Disk： /boot/initrd (/boot/initrd-version)；
  核心模块： /lib/modules/version/kernel 或 /lib/modules/$(uname -r)/kernel；
  核心原始码： /usr/src/linux 或 /usr/src/kernels/ (要安装才会有，默认不安装)
</code></pre>
</li>
</ul>
<h2 id="网络">网络</h2>
<ul>
<li>
<p>涉及</p>
<pre><code>   /etc/resolv.conf
   /etc/init.d/network restart
   /etc/sysconfig/iptables
</code></pre>
</li>
</ul>
<h2 id="gcc">gcc</h2>
<pre><code># 会自动的产生 hello.o 这个文件，并且进行最佳化喔！
gcc -O hello.c -c
# 进行 binary file 制作时，将连结的函式库与相关的路径填入
gcc sin.c -lm -L/usr/lib -I/usr/include
# 在编译的时候，输出较多的信息说明
gcc -o hello hello.c -Wall
</code></pre>
<h2 id="make">make</h2>
<ul>
<li>
<p>makefile</p>
<pre><code>  最终目标(target): 目标档1 目标档2
  &lt;tab&gt;   gcc -o 欲创建的运行档 目标档1 目标档2	
  # vi makefile
  LIBS = -lm
  OBJS = main.o haha.o sin_value.o cos_value.o
  main: ${OBJS}
          gcc -o main ${OBJS} ${LIBS}
  clean:
          rm -f main ${OBJS}		
</code></pre>
</li>
<li>
<p>使用</p>
<pre><code>   make clean main
</code></pre>
</li>
</ul>
<h2 id="软件安装">软件安装</h2>
<pre><code> /usr/local  自行安装的软件一般放置处
		/usr/local/xx/etc      配置
		/usr/local/xx/bin      运行
		/usr/local/xx/lib      函数库
		/usr/local/xx/man		说明	
</code></pre>
<h2 id="函数库">函数库</h2>
<pre><code> /etc/ld.so.conf  想要读入高速缓存当中的动态函式库所在的目录
 ldconfig -p      列出目前有的所有函式库数据内容 (在 /etc/ld.so.cache 内的数据！)
 ldd /usr/bin/passwd  找出 /usr/bin/passwd 这个文件的函式库数据
  md5sum CentOS-5.3-i386-netinstall.iso
  sha1sum CentOS-5.3-i386-netinstall.iso  查看加密码
</code></pre>
<h2 id="rpm-管理">rpm 管理</h2>
<ul>
<li>
<p>RPM 全名是『 RedHat Package Manager 』简称则为 RPM 啦！顾名思义，当初这个软件管理的机制是由 Red Hat 这家公司发展出来的。 RPM 是以一种数据库记录的方式来将你所需要的软件安装到你的 Linux 系统的一套管理机制。</p>
<ul>
<li>软件文件安装的环境必须与打包时的环境需求一致或相当；</li>
<li>需要满足软件的相依属性需求；</li>
<li>反安装时需要特别小心，最底层的软件不可先移除，否则可能造成整个系统的问题！</li>
</ul>
</li>
<li>
<p>SRPM  Source RPM 的意思，这个 SRPM 所提供的软件内容『并没有经过编译』， 他提供的是原始码</p>
<ul>
<li>先将该软件以 RPM 管理的方式编译，此时 SRPM 会被编译成为 RPM 文件；</li>
<li>然后将编译完成的 RPM 文件安装到 Linux 系统当中</li>
</ul>
</li>
<li>
<p>涉及目录命令</p>
<pre><code>  /var/lib/rpm/    软件相关信息的数据库放置处
  rpm -ivh package_name    安装
  rpm -Fvh package_name    rpm升级

  //查询安装
  rpm -qa                           查询全部已安装软件
  rpm -q[licdR] 已安装的软件名称       已安装软件

  			-q  ：仅查询，后面接的软件名称是否有安装；
  			-qa ：列出所有的，已经安装在本机 Linux 系统上面的所有软件名称；
  			-qi ：列出该软件的详细资讯 (information)，包含开发商、版本与说明等；
  			-ql ：列出该软件所有的文件与目录所在完整档名 (list)；
  			-qc ：列出该软件的所有配置档 (找出在 /etc/ 底下的档名而已)
  			-qd ：列出该软件的所有说明档 (找出与 man 有关的文件而已)
  			-qR ：列出与该软件有关的相依软件所含的文件 (Required 的意思)
  			-qf ：由后面接的文件名称，找出该文件属於哪一个已安装的软件；				

  rpm -qf 存在於系统上面的某个档名      已安装软件
  rpm -qp[licdR] 未安装的某个文件名称   查阅RPM文件		

  //查询修改
  rpm -Va       
  rpm -V  已安装的软件名称
  rpm -Vp 某个 RPM 文件的档名
  rpm -Vf 在系统上面的某个文件

  //卸载
   rpm -e package_name    卸载
   rpm --rebuilddb        重置rpm数据库
</code></pre>
</li>
</ul>
<h2 id="yum-管理">yum 管理</h2>
<ul>
<li>
<p>Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装</p>
</li>
<li>
<p>命令</p>
<pre><code>  vi /etc/yum.repos.d/CentOS-Base.repo   配置yum
  yum repolist all
  yum list updates  	列出目前服务器上可供本机进行升级的软件有哪些
  yum info mdadm    找出 mdadm 这个软件的功能为何
  yum search raid       查找相关软件

  yum [install|update] 软件
  yum [remove] 软件
  yum clean
</code></pre>
</li>
</ul>
<h1 id="服务器">服务器</h1>
<h2 id="网络-1">网络</h2>
<ul>
<li>
<p>ip</p>
<pre><code>  Public IP : 公共 IP ，经由 INTERNIC 所统一规划的 IP，有这种 IP 才可以连上 Internet ；

  Private IP : 私有 IP 或保留 IP，不能直接连上 Internet 的 IP ， 主要用于局域网络内的主机联机规划。

  Netmask, (子网掩码)，达成子网的切分
  Network/Netmask
  192.168.0.0/255.255.255.0
  192.168.0.0/24    &lt;==因为 Net_ID 共有 24 个 bits	

  Class A, B, C 三个等级的 Netmask 表示方式：
  Class A : 11111111.00000000.00000000.00000000 ==&gt; 255.  0.  0.  0
  Class B : 11111111.11111111.00000000.00000000 ==&gt; 255.255.  0.  0
  Class C : 11111111.11111111.11111111.00000000 ==&gt; 255.255.255.  0

  要是给予 Net_ID 是 26 位时，总共分为几段呢？ 因为 26-24=2 ，所以总共用掉两个位，因此有 2 的 2 次方，得到 4 个网段。再将 256 个 IP 平均分配到 4 个网段去

  网关/路由器的功能就是在负责不同网域之间的封包转递 (IP Forwarding) 如192.168.0.1 、192.168.1.1
  route  查看路由表 
</code></pre>
</li>
<li>
<p>cmd</p>
<pre><code>   MTU (Maximum Transmission Unit, 最大传输单位)

  ifconfig interface {options} 	  	 查看ip网络参数
  		选项与参数：
  		interface：网络卡接口代号，包括 eth0, eth1, ppp0 等等
  		options  ：可以接的参数，包括如下：
  		    up, down ：启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)
  		    mtu      ：可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)
  		    netmask  ：就是子屏蔽网络；
  		    broadcast：就是广播地址啊！


  /etc/init.d/network restart  重启网络
  route -n   网络路由状态

  ip link show  显示所有接口信息
  ip link set [device] [动作与参数]
  ip address show	  显示所有ip地址
  ip address [add|del] [IP参数] [dev 装置名] [相关参数]
  netstat -tlunp   追踪网络或插槽档
</code></pre>
</li>
</ul>
<h2 id="服务">服务</h2>
<ul>
<li>
<p>共 65536 个 port</p>
<ul>
<li>root 身份才能启动小于1024的端口</li>
<li>大于1024 的端口为client 端的软件激活的 port</li>
</ul>
</li>
<li>
<p>命令</p>
<pre><code>  netstat：在本机上面以自己的程序监测自己的 port；	
  	netstat -tlunp 
  nmap：透过网络的侦测软件辅助，可侦测非本机上的其他网络。

  /etc/supervisor/conf.d  设置服务处
  /etc/resolv.conf   DNS 主机 IP 的设定
</code></pre>
</li>
</ul>
<h2 id="防火墙-1">防火墙</h2>
<pre><code> iptables-save 观察防火墙规则
 iptables [-t nat] -P [INPUT,OUTPUT,FORWARD] [ACCEPT,DROP]  定义预设政策 (policy)
 
 iptables [-AI 链名] [-io 网络接口] [-p 协议] [-s 来源IP/网域] [-d 目标IP/网域] -j [ACCEPT|DROP|REJECT|LOG]
	 iptables -A INPUT -i eth1 -s 192.168.100.0/24 -j ACCEPT
	 iptables -A INPUT -i eth0 -p tcp --dport 139 -j ACCEPT

	选项与参数：
	-AI 链名：针对某的链进行规则的 &quot;插入&quot; 或 &quot;累加&quot;
	    -A ：新增加一条规则，该规则增加在原本规则的最后面。例如原本已经有四条规则，
	         使用 -A 就可以加上第五条规则！
	    -I ：插入一条规则。如果没有指定此规则的顺序，默认是插入变成第一条规则。
	         例如原本有四条规则，使用 -I 则该规则变成第一条，而原本四条变成 2~5 号
	    链 ：有 INPUT, OUTPUT, FORWARD 等，此链名称又与 -io 有关，请看底下。
	
	-io 网络接口：设定封包进出的接口规范
	    -i ：封包所进入的那个网络接口，例如 eth0, lo 等接口。需与 INPUT 链配合；
	    -o ：封包所传出的那个网络接口，需与 OUTPUT 链配合；
	
	-p 协定：设定此规则适用于哪种封包格式
	   主要的封包格式有： tcp, udp, icmp 及 all 。
	
	-s 来源 IP/网域：设定此规则之封包的来源项目，可指定单纯的 IP 或包括网域，例如：
	   IP  ：192.168.0.100
	   网域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。
	   若规范为『不许』时，则加上 ! 即可，例如：
	   -s ! 192.168.100.0/24 表示不许 192.168.100.0/24 之封包来源；
	
	-d 目标 IP/网域：同 -s ，只不过这里指的是目标的 IP 或网域。
	
	-j ：后面接动作，主要的动作有接受(ACCEPT)、丢弃(DROP)、拒绝(REJECT)及记录(LOG)
	--sport 埠口范围：限制来源的端口号码，端口号码可以是连续的，例如 1024:65535
	--dport 埠口范围：限制目标的端口号码。

	-m ：一些 iptables 的外挂模块，主要常见的有：
	     state ：状态模块
	     mac   ：网络卡硬件地址 (hardware address)
	--state ：一些封包的状态，主要有：
	     INVALID    ：无效的封包，例如数据破损的封包状态
	     ESTABLISHED：已经联机成功的联机状态；
	     NEW        ：想要新建立联机的封包状态；
	     RELATED    ：这个最常用！表示这个封包是与我们主机发送出去的封包有关
</code></pre>
<h2 id="tmux">tmux</h2>
<ul>
<li>
<p>窗口神器</p>
<pre><code>  打开新窗格 
  	 ctrl+b %   竖直
  	 ctrl+b &quot;     水平
  	切换 ctrl+b 方向	 
  打开新窗口      ctrl+b c
  	切换 ctrl+b 数字
</code></pre>
</li>
</ul>
<h2 id="ssh">ssh</h2>
<blockquote>
<p>目前 SSH 的协议版本有两种，分别是 version 1 与 version 2 ，其中 V2 由于加上了联机检测的机制， 可以避免联机期间被插入恶意的攻击码，因此比 V1 还要更加的安全</p>
</blockquote>
<h2 id="dns">DNS</h2>
<blockquote>
<p>Domain Name System，域名系统</p>
</blockquote>
<p>##参考</p>
<ul>
<li>鸟哥的私房菜</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Kafka机制一览</title>
      <link>https://justinbetter.github.io/2019/06/05/kafka%E6%9C%BA%E5%88%B6%E4%B8%80%E8%A7%88/</link>
      <pubDate>Wed, 05 Jun 2019 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2019/06/05/kafka%E6%9C%BA%E5%88%B6%E4%B8%80%E8%A7%88/</guid>
      <description>&lt;p&gt;Kafka：
topic、producer、consumer、broker&lt;/p&gt;
&lt;p&gt;topic本质就是一个目录,由一些Partition Logs(分区日志)组成（便于集群拓展、提高并发）
Kafka需要维持的元数据只有一个–消费消息在Partition中的offset值，Consumer每消费一个消息，offset就会加1。
其实消息的状态完全是由Consumer控制的，Consumer可以跟踪和重设这个offset值，这样的话Consumer就可以读取任意位置的消息&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Kafka：
topic、producer、consumer、broker</p>
<p>topic本质就是一个目录,由一些Partition Logs(分区日志)组成（便于集群拓展、提高并发）
Kafka需要维持的元数据只有一个–消费消息在Partition中的offset值，Consumer每消费一个消息，offset就会加1。
其实消息的状态完全是由Consumer控制的，Consumer可以跟踪和重设这个offset值，这样的话Consumer就可以读取任意位置的消息</p>
<p>允许用户为每个topic设置副本数量，副本数量决定了有几个broker来存放写入的数据；副本都是以partition为单位的，不过只有一个partition的副本会被选举成leader作为读写用</p>
<p>从Producer端看：Kafka是这么处理的，当一个消息被发送后，Producer会等待broker成功接收到消息的反馈（可通过参数控制等待时间），如果消息在途中丢失或是其中一个broker挂掉，Producer会重新发送（我们知道Kafka有备份机制，可以通过参数控制是否等待所有备份节点都收到消息）。
从Consumer端看：前面讲到过partition，broker端记录了partition中的一个offset值，这个值指向Consumer下一个即将消费message。当Consumer收到了消息，但却在处理过程中挂掉，此时Consumer可以通过这个offset值重新找到上一个消息再进行处理。Consumer还有权限控制这个offset值，对持久化到broker端的消息做任意处理。</p>
<p>为什么快？
顺序读写、分区、零拷贝、批量发送、数据压缩；
如何提高？生产端调整 batch.size、linger.ms（最多等待时间） 参数，以及主题分区数合理分配等。</p>
<p>存储？
在Kafka文件存储中，同一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为topic名称+有序序号
partition目录下Segment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀”.index”和“.log”分别表示为segment索引文件、数据文件。</p>
<p>生产者机制？
生产的流程主要就是一个producer线程和一个sender线程，它们之间通过BatchQueue来获取数据，它们的关系是一一对应的，所以kafka的生产过程都是异步过程，
数据最终是放在BatchQueue，像是将水流入了一个蓄水池的场景，这就是蓄水池机制
每条消息先从MetaData里面获取分区信息，再申请一段buffer空间形成一个批接收空间，RecordAccumulator 会将收到的每条消息append到这个buffer中，最后将每个批次压入到队列当中，等待Sender线程来获取发送。
buffer空间 ：
BufferPool（缓冲池）对象，整个KafkaProducer实例中只有一个BufferPool对象。内存池总大小，它是已使用空间和可使用空间的总和，内存缓冲池的设计，让整个发送过程中的存储空间循环利用，有效减少JVM GC造成的影响
Sender 是一个发送线程，负责读取记录收集器中缓存的批量消息，经过一些中间转换操作，将要发送的数据准备好，然后交由 Selector 进行网络传输。
<a href="https://zhuanlan.zhihu.com/p/137811719">https://zhuanlan.zhihu.com/p/137811719</a></p>
<p>消息是kafka中最基本的数据单元，一条消息由key,value组成，producer往broker中的指定topic中发送一条消息，producer会根据这条消息的key的hashcode值%分区数取模，来确定这个消息分配到那个Partition分区；
acks参数指定了必须要有多少个分区副本收到消息，生产者才认为该消息是写入成功的
acks=0，表示生产者在成功写入消息之前不会等待任何来自服务器的响应.
acks=1，表示只要集群的leader分区副本接收到了消息，就会向生产者发送一个成功响应的ack，
acks =all,表示只有所有参与复制的节点(ISR列表的副本)全部收到消息时，生产者才会接收到来自服务器的响应；延迟高</p>
<p>消费者机制？
Kafka有两种模式消费数据：队列 和发布订阅 ；在队列模式下，一条数据只会发 送给 customer group中的一个 customer 进行消费；在发布订阅模式下，一条数据会发送给多个 customer进行消费。
消费者组，那自然是由消费者组成的，组内可以有一个或多个消费者实例，而这些消费者实例共享一个id，称为group id
一个消费者组中，每一个分区只能由组内的一消费者订阅；消费者组大于分区数多的会空闲
重平衡（Rebalance）其实就是一个协议，它规定了如何让消费者组下的所有消费者来分配topic中的每一个分区；kafka基本处于不可用状态
Kafka的数据是按照分区进行排序(插入的顺序 )，也就是每个分区中的数据有序的，但是多个分区之间做不到全局有序</p>
<p>零拷贝原理：
传统拷贝涉及到用户空间和内核空间的切换，使用DMA可以直接存取内存，不需要CPU调度；
通过DMA直接网卡访问内存，实现零拷贝；
操作系统提供 了一个优化的代码路径，页缓存到socket，linux上是通过 sendfile 系统调用来
Kafka在文件传输的过程中正是使用了零拷贝技术对文件进行拷贝</p>
<p>选举？
quorum（法定人数）
quorum是一种在分布式系统中常用的算法，主要用来通过数据冗余来保证数据一致性的投票算法。在kafka中该算法的实现就是ISR，在ISR中就是可以被选举为leader的法定人数。
ISR（in-sync replicas）列表。每个分区的 leader 会维护一个 ISR 列表，ISR 列表里面就是 follower 副本的 Borker 编号，只有跟得上 Leader 的 follower 副本才能加入到 ISR 里面
当 Leader 挂掉了，而且 unclean.leader.election.enable=false 的情况下，Kafka 会从 ISR 列表中选择第一个 follower 作为新的 Leader</p>
<p>如何保证数据一致性的？
一致性定义:若某条消息对Consumer可见,那么即使Leader宕机了,在新Leader上数据依然可以被读到
因为所有的 ISR 都同步了 Message2，只有 High Water Mark 以上的消息才支持 Consumer 读取，而 High Water Mark 取决于 ISR 列表里面偏移量最小的分区，对应于上图的副本2，这个很类似于木桶原理。
HighWaterMark简称HW: Partition的高水位，取一个partition对应的ISR中最小的LEO作为HW，消费者最多只能消费到HW所在的位置，另外每个replica都有highWatermark，leader和follower各自负责更新自己的highWatermark状态，highWatermark &lt;= leader. LogEndOffset
对于Leader新写入的msg，Consumer不能立刻消费，Leader会等待该消息被所有ISR中的replica同步后,更新HW,此时该消息才能被Consumer消费，即Consumer最多只能消费到HW位置
这样就保证了如果Leader Broker失效,该消息仍然可以从新选举的Leader中获取。对于来自内部Broker的读取请求,没有HW的限制。同时,Follower也会维护一份自己的HW,Folloer.HW = min(Leader.HW, Follower.offset)</p>
<p>HW缺陷？
消息同步LEO不一致，follower日志截断，异步延迟，
leader 中保存的 remote LEO 值的更新总是需要额外一轮 fetch RPC 请求才能完成，这意味着在 leader 切换过程中，会存在数据丢失以及数据不一致的问题
为了解决 HW 更新时机是异步延迟，leader epoch 机制，在每个副本日志目录下都创建一个 leader-epoch-checkpoint 文件用于保存 leader 的 epoch 信息</p>
<p>副本机制？
在Kafka集群中，会有一个broker被选举出来作为controller，这个controller负责管理和协调Kafka集群中的所有节点
controller会在集群启动时为每个节点注册一个监听器，当节点发生改变时可以动态的管理节点，在管理副本时，Kafka通过ISR机制管理副本同步，还会选举出leader来管理整个集群的数据和同步配置信息</p>
<p>Kafka 分区数越多性能就越好吗？为什么？
每个分区数都对应一个 log 文件，log 文件是顺序写的，但如果有非常多分区同时刷盘，就会变相成乱序写了
客户端会为每个分区调用一条线程处理，多线程并发地处理分区消息，分区越多，意味着处理的线程数也就越多
一个 broker 挂掉后，如果此时分区特别多，Kafka 分区 leader 重新选举的时间大大增加
客户端在会为每个分区分配一定的缓冲区，如果分区过多，分配的内存也越大</p>
<p>有序？
卡夫卡是无法保证全局的消息顺序性的，只能保证主题的某个分区的消息顺序性
如何保证？需要有序的消息都发往同一个分区，这样就保证了局部有序；</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>正则</title>
      <link>https://justinbetter.github.io/2018/07/18/%E6%AD%A3%E5%88%99/</link>
      <pubDate>Wed, 18 Jul 2018 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2018/07/18/%E6%AD%A3%E5%88%99/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;正则&#34;&gt;正则&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;正则表达式(regular expression)描述了一种字符串匹配的模式（pattern）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;元字符&#34;&gt;元字符&lt;/h2&gt;
&lt;p&gt;一些有特殊含义的字符，帮助建立匹配规则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\ 转义字符
^ 匹配开始位置 ps：当在一组方括号里使用^是，它表示&amp;quot;非&amp;quot;或&amp;quot;排除&amp;quot;的意思，常常用来剔除某个字符。
$ 匹配结束位置	
	ps：字符^和$同时使用时，表示精确匹配（字符串与模式一样），分开使用，只匹配字符串首或尾

+ 一次或多次
* 0次或多次
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ps：&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>[TOC]</p>
<h1 id="正则">正则</h1>
<pre><code>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern）
</code></pre>
<h2 id="元字符">元字符</h2>
<p>一些有特殊含义的字符，帮助建立匹配规则</p>
<pre><code>\ 转义字符
^ 匹配开始位置 ps：当在一组方括号里使用^是，它表示&quot;非&quot;或&quot;排除&quot;的意思，常常用来剔除某个字符。
$ 匹配结束位置	
	ps：字符^和$同时使用时，表示精确匹配（字符串与模式一样），分开使用，只匹配字符串首或尾

+ 一次或多次
* 0次或多次
</code></pre>
<p>ps：</p>
<pre><code>？0次或1次,也可以将默认的贪婪模式转变为非贪婪，例如，对于字符串 &quot;oooo&quot;，'o+?' 将匹配单个 &quot;o&quot;，而 'o+' 将匹配所有 'o'。
	（?:pattern) 获取匹配结果，但是不需要存储为分组结果	
	（?=pattern) 例如，&quot;Windows(?=95|98|NT|2000)&quot;能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;，但不能匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;。
     (?!pattern) 例如&quot;Windows(?!95|98|NT|2000)&quot;能匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;，但不能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;。


{n,m} 限定出现次数

*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。

[^指定字符串] 指的是除指定字符串以外的其他字符串
[] 匹配其中之一，可匹配字符组的一个列表，
（） 可作为子匹配进行分组缓存，分组获取的结果可以通过组编号（从1开始）拿出，
	**\n访问分组的引用**，可以用来去重

x|y 匹配 x 或 y
\s 匹配任何空白字符，包括空格、制表符、换页符等
\S 匹配任何非空白字符
\n 匹配一个换行符
\r 匹配一个回车符
. 匹配除换行符 \n 之外的任何单字符
\b 匹配一个单词边界，是不是在单词的首尾；\B 相反
\d 匹配一个数字字符。等价于 [0-9]。
\D 匹配一个非数字字符。等价于 [^0-9]。
\w 匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。
[a-z]  //匹配所有的小写字母
[A-Z]  //匹配所有的大写字母
[a-zA-Z]  //匹配所有的字母
[0-9]  //匹配所有的数字
[0-9\.\-]  //匹配所有的数字，句号和减号
[ \f\r\t\n]  //匹配所有的白字符
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>记录类型转换引起的索引失效</title>
      <link>https://justinbetter.github.io/2018/05/05/%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%BC%95%E8%B5%B7%E7%9A%84%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</link>
      <pubDate>Sat, 05 May 2018 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2018/05/05/%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%BC%95%E8%B5%B7%E7%9A%84%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</guid>
      <description>&lt;p&gt;mysql在进行字段对比时，如果两个参数类型不一致，此时会进行类型转换，让他们可以进行比较。
可以在sql中进行显示转换，或者在执行时自动进行隐式转换（应该避免，效率低且容易出错）。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>mysql在进行字段对比时，如果两个参数类型不一致，此时会进行类型转换，让他们可以进行比较。
可以在sql中进行显示转换，或者在执行时自动进行隐式转换（应该避免，效率低且容易出错）。</p>
<p>比如对于字符的查询，如果传入数字，则不能用索引，用单引号括起来才能用上索引。
原因是对于数字的1， 字符串‘1’， ‘01’，‘0001’都和它相等。从而就没法使用索引；
而反过来可以看出对于数字的查询传入字符串和数字都能用上索引；</p>
<p>string与number的类型进行对比为什么会导致索引失效以至于全表扫描呢。
原来对于column为string类型的索引，如果有三个值分别为&quot; 1&quot;,&quot; 1&quot;,“1a”。
在进行隐式转换成number后的值都为1。这种情况下索引自然就不可用。
mysql便不会通过索引进行快速查询，而是将对对应column全部进行类型转换后通过全表扫描来进行查询。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>学会写shell脚本</title>
      <link>https://justinbetter.github.io/2018/03/01/%E5%AD%A6%E4%BC%9A%E5%86%99shell%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Thu, 01 Mar 2018 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2018/03/01/%E5%AD%A6%E4%BC%9A%E5%86%99shell%E8%84%9A%E6%9C%AC/</guid>
      <description>&lt;p&gt;##shell是什么&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	Shell 是一个用C语言编写的程序，它是用户使用Linux的桥梁。
	Shell既是一种命令语言，又是一种程序设计语言，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##shell脚本是什么&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>##shell是什么</p>
<pre><code>	Shell 是一个用C语言编写的程序，它是用户使用Linux的桥梁。
	Shell既是一种命令语言，又是一种程序设计语言，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。
</code></pre>
<p>##shell脚本是什么</p>
<ul>
<li>
<p>shell是为shell编写的脚本程序。</p>
</li>
<li>
<p>Bash是大多数Linux系统默认的Shell。</p>
<pre><code>  #! 告诉系统其后路径所指定的程序即是解释此脚本文件的Shell程序。
  如： #!/bin/bash
</code></pre>
</li>
<li>
<p>运行方法</p>
<pre><code>  第一种： 
  chmod +x ./test.sh  #使脚本具有执行
  ./test.sh  #执行脚本
  第二种：
  /bin/sh test.sh #运行解释器
</code></pre>
</li>
</ul>
<p>##变量</p>
<ul>
<li>
<p>使用变量</p>
<pre><code>  your_name=&quot;qinjx&quot;
  echo $your_name
  echo ${your_name} #花括号可加可不加
</code></pre>
</li>
<li>
<p>设置只读变量</p>
<pre><code>  myUrl=&quot;http://www.w3cschool.cc&quot;
  readonly myUrl
</code></pre>
</li>
<li>
<p>删除变量 unset</p>
</li>
</ul>
<p>##字符串</p>
<ul>
<li>
<p>获取长度</p>
<pre><code>  string=&quot;abcd&quot;
  echo ${#string} #输出 长度4
</code></pre>
</li>
<li>
<p>提取字符串</p>
<pre><code>  echo ${string:1:4}
</code></pre>
</li>
<li>
<p>查找index</p>
<pre><code>  string=&quot;runoob is a great company&quot;
  echo `expr index &quot;$string&quot; is`  # 输出 8
</code></pre>
</li>
</ul>
<p>##数组</p>
<ul>
<li>
<p>定义</p>
<pre><code>  array_name=(value0 value1 value2 value3)
</code></pre>
</li>
<li>
<p>读取</p>
<pre><code>  valuen=${array_name[n]}
  echo ${array_name[@]} #获取所有元素
</code></pre>
</li>
<li>
<p>获取长度</p>
<pre><code>  length=${#array_name[@]}	
  lengthn=${#array_name[n]}
</code></pre>
</li>
</ul>
<p>##脚本参数</p>
<ul>
<li>
<p>获取参数</p>
<pre><code>  脚本内获取参数的格式为：$n

  $#	传递到脚本的参数个数

  $*	以一个单字符串显示所有向脚本传递的参数。

  如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。


  如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。
</code></pre>
</li>
</ul>
<h2 id="运算符">运算符</h2>
<ul>
<li>
<p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。
expr 是一款表达式计算工具，使用它能完成表达式的求值。例如，两个数相加(注意使用的是反引号 ` 而不是单引号 &lsquo;)：</p>
<pre><code>  #!/bin/bash

  val=`expr 2 + 2`
  echo &quot;两数之和为 : $val&quot;
</code></pre>
</li>
</ul>
<p>##echo
。。。没啥说的，就是显示
##printf</p>
<pre><code>printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 
</code></pre>
<p>##if
if condition1
then
command1
elif condition2
then
command2
else
commandN
fi</p>
<p>##for
for var in item1 item2 &hellip; itemN
do
command1
command2
&hellip;
commandN
done
##while
while condition
do
command
done</p>
<p>##函数</p>
<ul>
<li>
<p>使用</p>
</li>
<li>
<p>funWithReturn(){
echo &ldquo;这个函数会对输入的两个数字进行相加运算&hellip;&rdquo;
echo &ldquo;输入第一个数字: &quot;
read aNum
echo &ldquo;输入第二个数字: &quot;
read anotherNum
echo &ldquo;两个数字分别为 $aNum 和 $anotherNum !&rdquo;
return $(($aNum+$anotherNum))
}
funWithReturn
echo &ldquo;输入的两个数字之和为 $? !&rdquo;
#函数返回值在调用该函数后通过 $? 来获得</p>
</li>
<li>
<p>函数参数</p>
</li>
<li>
<p>funWithParam(){
echo &ldquo;第一个参数为 $1 !&rdquo;
echo &ldquo;第二个参数为 $2 !&rdquo;
echo &ldquo;第十个参数为 $10 !&rdquo;
echo &ldquo;第十个参数为 ${10} !&rdquo;
echo &ldquo;第十一个参数为 ${11} !&rdquo;
echo &ldquo;参数总数有 $# 个!&rdquo;
echo &ldquo;作为一个字符串输出所有参数 $* !&rdquo;
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73</p>
</li>
</ul>
<p>##包含外部脚本，以便独立使用</p>
<ul>
<li>
<p>source 或者 .</p>
<pre><code>  #使用 . 号来引用test1.sh 文件
  . ./test1.sh

  # 或者使用以下包含文件代码
  # source ./test1.sh
</code></pre>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>记录一些kotlin的用法</title>
      <link>https://justinbetter.github.io/2017/07/18/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9Bkotlin%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Tue, 18 Jul 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2017/07/18/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9Bkotlin%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;操作符&#34;&gt;操作符&lt;/h1&gt;
&lt;h3 id=&#34;elvis-操作符-&#34;&gt;Elvis 操作符 ?:&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;val a = b?.length ?: -1
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;安全转换-as&#34;&gt;安全转换 as？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;转型不成功返回 null&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;null-safety&#34;&gt;null safety&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var a : String? = null
a?.length //a 为null 则pass，不为null 则调用
a!!.length// 抛异常
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;类型判断符-is&#34;&gt;类型判断符 is&lt;/h3&gt;
&lt;h3 id=&#34;范围操作符--in&#34;&gt;范围操作符 : in&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for(i in 1..5 step 1){}
for (i in 5 downTo 1 step 2){}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;多行输入符--&#34;&gt;多行输入符  &amp;quot;&amp;quot;&amp;quot;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;三个双引号之间的内容将被原样保留&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;扩展函数&#34;&gt;扩展函数&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;run&#34;&gt;run&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;调用函数块，块内 this指代调用对象&lt;/li&gt;
&lt;li&gt;返回值为最后一行&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;val result = &amp;#34;haha&amp;#34;.run{
	println(this)
	&amp;#34;I&amp;#39;m result&amp;#34;
}
println(result)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;apply&#34;&gt;apply&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;同run，函数块内this 指代该对象&lt;/li&gt;
&lt;li&gt;返回值为对象自己&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;let&#34;&gt;let&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数块内 it 指代该对象&lt;/li&gt;
&lt;li&gt;返回值最后一行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;also&#34;&gt;also&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数块内it 指代该对象&lt;/li&gt;
&lt;li&gt;返回值为对象自己&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;with&#34;&gt;with&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将该对象作为函数参数&lt;/li&gt;
&lt;li&gt;this 指代该对象&lt;/li&gt;
&lt;li&gt;返回值为最后一行&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;val result = with（&amp;#34;haha&amp;#34;）{
	println(this)
	&amp;#34;result&amp;#34;
}
println(result)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;修饰符&#34;&gt;修饰符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;private 只能被自己所在的文件可见，不能在定义这个类之外的文件中使用&lt;/li&gt;
&lt;li&gt;protected 可以被成员自己和继承它的成员可见（比如，类和它的子类）&lt;/li&gt;
&lt;li&gt;internal 对所在的整个module可见&lt;/li&gt;
&lt;li&gt;public 最没有限制的修饰符。这是默认的修饰符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;委托属性&#34;&gt;委托属性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个属性具有一些相同的行为，使用lazy或者observable可以被很有趣地实现重用。而不是一次又一次地去声明那些相同的代码&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="操作符">操作符</h1>
<h3 id="elvis-操作符-">Elvis 操作符 ?:</h3>
<pre tabindex="0"><code>val a = b?.length ?: -1
</code></pre><h3 id="安全转换-as">安全转换 as？</h3>
<ul>
<li>转型不成功返回 null</li>
</ul>
<h3 id="null-safety">null safety</h3>
<pre tabindex="0"><code>var a : String? = null
a?.length //a 为null 则pass，不为null 则调用
a!!.length// 抛异常
</code></pre><h3 id="类型判断符-is">类型判断符 is</h3>
<h3 id="范围操作符--in">范围操作符 : in</h3>
<pre tabindex="0"><code>for(i in 1..5 step 1){}
for (i in 5 downTo 1 step 2){}
</code></pre><h3 id="多行输入符--">多行输入符  &quot;&quot;&quot;</h3>
<ul>
<li>三个双引号之间的内容将被原样保留</li>
</ul>
<h1 id="扩展函数">扩展函数</h1>
<hr>
<h2 id="run">run</h2>
<ul>
<li>调用函数块，块内 this指代调用对象</li>
<li>返回值为最后一行</li>
</ul>
<pre tabindex="0"><code>val result = &#34;haha&#34;.run{
	println(this)
	&#34;I&#39;m result&#34;
}
println(result)
</code></pre><h2 id="apply">apply</h2>
<ul>
<li>同run，函数块内this 指代该对象</li>
<li>返回值为对象自己</li>
</ul>
<h2 id="let">let</h2>
<ul>
<li>函数块内 it 指代该对象</li>
<li>返回值最后一行</li>
</ul>
<h2 id="also">also</h2>
<ul>
<li>函数块内it 指代该对象</li>
<li>返回值为对象自己</li>
</ul>
<h2 id="with">with</h2>
<ul>
<li>将该对象作为函数参数</li>
<li>this 指代该对象</li>
<li>返回值为最后一行</li>
</ul>
<pre tabindex="0"><code>val result = with（&#34;haha&#34;）{
	println(this)
	&#34;result&#34;
}
println(result)
</code></pre><h2 id="修饰符">修饰符</h2>
<ul>
<li>private 只能被自己所在的文件可见，不能在定义这个类之外的文件中使用</li>
<li>protected 可以被成员自己和继承它的成员可见（比如，类和它的子类）</li>
<li>internal 对所在的整个module可见</li>
<li>public 最没有限制的修饰符。这是默认的修饰符</li>
</ul>
<h2 id="委托属性">委托属性</h2>
<ul>
<li>
<p>一个属性具有一些相同的行为，使用lazy或者observable可以被很有趣地实现重用。而不是一次又一次地去声明那些相同的代码</p>
</li>
<li>
<p><a href="https://wangjiegulu.gitbooks.io/kotlin-for-android-developers-zh/content/biao_zhun_wei_tuo.html">https://wangjiegulu.gitbooks.io/kotlin-for-android-developers-zh/content/biao_zhun_wei_tuo.html</a></p>
</li>
<li>
<p>标准委托</p>
<pre><code>  by lazy
  by observable
  by Delegates.notNull()
  by map 
</code></pre>
</li>
<li>
<p>自定义委托 ：</p>
<pre><code>  	继承ReadWriteProperty
  by DelegatesExt.notNullSingleValue()
</code></pre>
</li>
<li>
<p>操作符</p>
</li>
<li>
<p>密封类 sealed</p>
<ul>
<li>
<p>类似枚举，不同之处在于枚举的实例是唯一的，而密封类可以有很多实例，它们可以有不同的状态。</p>
<pre><code>  sealed class Option&lt;out T&gt; {
      class Some&lt;out T&gt; : Option&lt;T&gt;()
      object None : Option&lt;Nothing&gt;()
  }		
</code></pre>
</li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://wangjiegulu.gitbooks.io/kotlin-for-android-developers-zh/content/biao_zhun_wei_tuo.html">https://wangjiegulu.gitbooks.io/kotlin-for-android-developers-zh/content/biao_zhun_wei_tuo.html</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>常用的设计模式</title>
      <link>https://justinbetter.github.io/2017/05/28/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 28 May 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2017/05/28/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;@[toc]
#设计模式&lt;/p&gt;
&lt;p&gt;##单例模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Double Check Lock&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton &lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(mInstance &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt;(Singleton.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(mInstance &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mInstance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Singleton();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  retuen mInstance;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;静态内部类&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton &lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    retuen SingletonHolder.&lt;span style=&#34;color:#a6e22e&#34;&gt;sInstance&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SingletonHolder&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Singleton sInstance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Singleton();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI3ODA5ODctNjBjYmI1YjliZjk1Y2YxOS5wbmc?x-oss-process=image/format,png&#34; alt=&#34;Paste_Image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;##Builder模式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存储参数&lt;/li&gt;
&lt;li&gt;设置参数，return this&lt;/li&gt;
&lt;li&gt;new 对象，传递参数&lt;/li&gt;
&lt;li&gt;返回&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##原型模式&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>@[toc]
#设计模式</p>
<p>##单例模式</p>
<ul>
<li>Double Check Lock</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Singleton <span style="color:#a6e22e">getInstance</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(mInstance <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">synchronized</span>(Singleton.<span style="color:#a6e22e">class</span>){
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(mInstance <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>        mInstance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton();
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  retuen mInstance;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>静态内部类</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Singleton <span style="color:#a6e22e">getInstance</span>(){
</span></span><span style="display:flex;"><span>    retuen SingletonHolder.<span style="color:#a6e22e">sInstance</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SingletonHolder</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Singleton sInstance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton();
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>​</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI3ODA5ODctNjBjYmI1YjliZjk1Y2YxOS5wbmc?x-oss-process=image/format,png" alt="Paste_Image.png"></p>
<p>##Builder模式</p>
<ol>
<li>存储参数</li>
<li>设置参数，return this</li>
<li>new 对象，传递参数</li>
<li>返回</li>
</ol>
<p>##原型模式</p>
<ul>
<li>使用
<ul>
<li>重写clone()</li>
<li>浅拷贝：拷贝对象无法修改原型对象的字段，保证了安全性（除了引用型字段，多以也要拷贝引用性字段）</li>
<li>深拷贝： 对拷贝对象的引用型字段也要拷贝</li>
</ul>
</li>
</ul>
<h2 id="工厂方法模式">工厂方法模式</h2>
<pre tabindex="0"><code>//抽象产品类
public abstract class Dialog(){
  public abstract void show();
}

public class DialogA extends Dialog{
  @Override
  public void show(){
    //showA
  }
}
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//抽象工厂</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Factory</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#f92672">&lt;</span>T <span style="color:#66d9ef">extends</span> Dialog<span style="color:#f92672">&gt;</span>T <span style="color:#a6e22e">createDialog</span>(Class<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> clazz);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DialogAFactory</span> <span style="color:#66d9ef">extends</span> Factory{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#f92672">&lt;</span>T <span style="color:#66d9ef">extends</span> Dialog<span style="color:#f92672">&gt;</span>T <span style="color:#a6e22e">createDialog</span>(Class<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> clazz){
</span></span><span style="display:flex;"><span>    Dialog dialog <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>{
</span></span><span style="display:flex;"><span>      dialog <span style="color:#f92672">=</span> (Dialog)Class.<span style="color:#a6e22e">forName</span>(clazz.<span style="color:#a6e22e">getName</span>()).<span style="color:#a6e22e">newInstance</span>();
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">catch</span>(Exception e){
</span></span><span style="display:flex;"><span>      ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (T)dialog;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//使用</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>  Factory factory <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DialogFactory();
</span></span><span style="display:flex;"><span>  DialogA a <span style="color:#f92672">=</span> factory.<span style="color:#a6e22e">createDialog</span>(DialogA.<span style="color:#a6e22e">class</span>);
</span></span><span style="display:flex;"><span>  a.<span style="color:#a6e22e">show</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="抽象工厂模式">抽象工厂模式</h2>
<ul>
<li>角色
<ul>
<li>抽身产品接口</li>
<li>具体产品类</li>
<li>抽象工厂类</li>
<li>具体工厂类：每一个产品不同组成不同具体工厂</li>
</ul>
</li>
<li>面向接口编程，但是工厂类过多，不易拓展</li>
</ul>
<h2 id="策略模式">策略模式</h2>
<ul>
<li>角色
<ul>
<li>策略的抽象</li>
<li>具体的策略实现</li>
<li>操作策略的具体实现</li>
</ul>
</li>
<li>代码</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//策略抽象接口</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CalculateStrategy</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">calculatePrice</span>(<span style="color:#66d9ef">int</span> km);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//具体策略</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BusStrategy</span> <span style="color:#66d9ef">implements</span> CalculateStrategy{
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">calculatePrice</span>(<span style="color:#66d9ef">int</span> km){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> busPrice;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Context角色</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Context</span>{
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">private</span> CalculateStrategy cs;
</span></span><span style="display:flex;"><span>  	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">seCalculateStrategy</span>(CalculateStrategy cs){
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">cs</span> <span style="color:#f92672">=</span> cs;
</span></span><span style="display:flex;"><span>  	}
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">calculatePrice</span>(<span style="color:#66d9ef">int</span> km){
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> cs.<span style="color:#a6e22e">calculatePrice</span>(km);
</span></span><span style="display:flex;"><span>  	}
</span></span><span style="display:flex;"><span>  	
</span></span><span style="display:flex;"><span>  	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>      Context context <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Context();
</span></span><span style="display:flex;"><span>      context.<span style="color:#a6e22e">setCalculateStrategy</span>(<span style="color:#66d9ef">new</span> BusStrategy());
</span></span><span style="display:flex;"><span>      context.<span style="color:#a6e22e">calculatePrice</span>(15);
</span></span><span style="display:flex;"><span>  	}
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="状态模式">状态模式</h2>
<ul>
<li>角色
<ul>
<li>抽象状态类或接口：设置状态下的行为</li>
<li>具体状态类或接口：不同状态不同行为</li>
<li>Context环境类</li>
</ul>
</li>
<li>代码:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//抽象状态：定义行为</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">UserState</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">forward</span>();
</span></span><span style="display:flex;"><span>  	
</span></span><span style="display:flex;"><span>  	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">comment</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//具体状态：已登录</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LoginedState</span> <span style="color:#66d9ef">implements</span> UserState{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">forward</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//转发</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">comment</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//评论</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//具体状态：未登录</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogoutState</span> <span style="color:#66d9ef">implements</span> UserState{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">forward</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//去登陆</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">comment</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//去登陆</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//使用</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LoginContext</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> UserState mUserState <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LogoutState();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">LoginContext</span>(){}
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> LoginContext mLoginContext <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LoginContext();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> LoginContext <span style="color:#a6e22e">getInstance</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> mLoginContext();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setState</span>(UserState userState){
</span></span><span style="display:flex;"><span>    mUserState <span style="color:#f92672">=</span> userState;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">forward</span>(){
</span></span><span style="display:flex;"><span>    mUserState.<span style="color:#a6e22e">forward</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">comment</span>(){
</span></span><span style="display:flex;"><span>    mUserState.<span style="color:#a6e22e">comment</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="责任链模式">责任链模式</h2>
<ul>
<li>角色
<ul>
<li>抽象处理者</li>
<li>抽象请求者</li>
<li>具体处理者</li>
<li>具体请求者</li>
</ul>
</li>
<li>代码</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//抽象处理者</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractHandler</span>{
</span></span><span style="display:flex;"><span>  protect AbstractHandler nextHandler;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">handleRequest</span>(AbstractRequest request){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(getHandlerLevel() <span style="color:#f92672">==</span> request.<span style="color:#a6e22e">getRequestLevel</span>()){
</span></span><span style="display:flex;"><span>    	handleRequest(request);
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(nextHandler <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>        nextHandler.<span style="color:#a6e22e">handleRequest</span>(request);
</span></span><span style="display:flex;"><span>      }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;All of handler can not handle the request&#34;</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getHandlerLevel</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">handleRequest</span>(AbstractRequest request);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//抽象请求者</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractRequest</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> Object obj;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AbstractRequest</span> (Object obj){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> obj;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">getContent</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> obj;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getRequestLevel</span>();
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//具体处理者</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Handler1</span> <span style="color:#66d9ef">extends</span> AbstractHandler{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getHandleLevel</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">handleRequest</span>(AbstractRequest request){
</span></span><span style="display:flex;"><span>    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;handler1 handle the request!&#34;</span><span style="color:#f92672">+</span>request.<span style="color:#a6e22e">getRequestLevel</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//具体请求者</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Request1</span> <span style="color:#66d9ef">extends</span> AbstractRequest{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Request1</span>(Object obj){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">super</span>(obj);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getReqestLevel</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//使用</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args){
</span></span><span style="display:flex;"><span>  AbstractHandler handler1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Handler1();
</span></span><span style="display:flex;"><span>  AbstractHandler handler2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Handler2();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  handler1.<span style="color:#a6e22e">nextHandler</span> <span style="color:#f92672">=</span> handler2;
</span></span><span style="display:flex;"><span>  handler1.<span style="color:#a6e22e">handlerRequest</span>(<span style="color:#66d9ef">new</span> Request1(<span style="color:#e6db74">&#34;Request1&#34;</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="解释器模式">解释器模式</h2>
<ul>
<li>角色
<ul>
<li>抽象表达式，抽象的解释方法</li>
<li>终结符表达式</li>
<li>非终结符表达式</li>
<li>环境类Context</li>
<li>客户类Client</li>
</ul>
</li>
<li>一般很少用</li>
</ul>
<h2 id="命令模式">命令模式</h2>
<ul>
<li>角色
<ul>
<li>接收者，具体逻辑</li>
<li>命令抽象接口</li>
<li>具体命令</li>
<li>请求者</li>
<li>客户端</li>
</ul>
</li>
<li>将请求封装成一个对象，从而使用不同请求把客户端参数化：取消、日志、事务</li>
</ul>
<h2 id="观察者模式">观察者模式</h2>
<ul>
<li>角色
<ul>
<li>抽象主题，被观察者Observable</li>
<li>具体主题，Concrete Observable</li>
<li>抽象观察者，Obsever</li>
<li>具体观察者</li>
</ul>
</li>
<li>对象间一种一对多的依赖关系，每当一个对象改变状态，则所有依赖于它的对象都会通知并被自动更新</li>
<li>代码：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//具体主题</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Website</span> <span style="color:#66d9ef">extends</span> Observable{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postNewPublication</span>(String content){
</span></span><span style="display:flex;"><span>    setChanged();
</span></span><span style="display:flex;"><span>    notifyObserver(content);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//具体观察者</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Subscriber</span> <span style="color:#66d9ef">extends</span> Observer{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(observable 0,Object content){
</span></span><span style="display:flex;"><span>      System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;更新的内容是：&#34;</span><span style="color:#f92672">+</span>content);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//使用</span>
</span></span><span style="display:flex;"><span>main<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>  	Website web <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Website();
</span></span><span style="display:flex;"><span>	Subscriber sub <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Subscriber();
</span></span><span style="display:flex;"><span>	web.<span style="color:#a6e22e">addObserver</span>(sub);
</span></span><span style="display:flex;"><span>	web.<span style="color:#a6e22e">postNewPublication</span>(<span style="color:#e6db74">&#34;内容更新了！&#34;</span>);
</span></span><span style="display:flex;"><span>	
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>【cs基础】编译器的普及</title>
      <link>https://justinbetter.github.io/2017/04/02/cs%E5%9F%BA%E7%A1%80%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%99%AE%E5%8F%8A/</link>
      <pubDate>Sun, 02 Apr 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2017/04/02/cs%E5%9F%BA%E7%A1%80%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%99%AE%E5%8F%8A/</guid>
      <description>&lt;p&gt;##编译器是什么
编译器就是一种翻译程序，一般是将高级语言编写的源代码转化成汇编或者机器码。说白了就是把我们用python,java等各种语言写的程序,翻译成计算机能看懂的二进制指令数据,以便运行.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>##编译器是什么
编译器就是一种翻译程序，一般是将高级语言编写的源代码转化成汇编或者机器码。说白了就是把我们用python,java等各种语言写的程序,翻译成计算机能看懂的二进制指令数据,以便运行.</p>
<p>##编译流程</p>
<blockquote>
<p>source &ndash;&gt; 词法分析 == 各种记号Token stream
&ndash;&gt; 语法分析 == 语法树
&ndash;&gt; 语义分析 == 优化后的语法树
&ndash;&gt; 中间代码生成 == 中间代码
&ndash;&gt; 中间代码优化 == 优化后的中间代码
&ndash;&gt; 目标代码生成 == 目标代码
&ndash;&gt; 目标代码优化 == target program</p>
</blockquote>
<p>##流程详解</p>
<ol>
<li>
<p>词法分析</p>
<pre><code>  将源代码的标识符、运算符等分割成一个个记号
</code></pre>
</li>
<li>
<p>语法分析</p>
<pre><code> 解析得到的一个个记号，根据语法规则生成一种抽象语法树
</code></pre>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kaiAzFVr-1598890932828)(http://pandolia.net/tinyc/images/syntax_tree-2.png)]</p>
</li>
<li>
<p>语义分析</p>
<pre><code> 编译器开始对语法树进行一次或多次的遍历，检查程序的语义规则：变量声明、类型匹配..等
</code></pre>
</li>
<li>
<p>IR生成（中间代码，intermediate Representation）</p>
<pre><code> 一般生成的算法是一个递归的算法，递归的遍历语法树，将语法树上的一些节点替换成中间代码块，再根据特定的规则和顺序将这些中间代码块拼装起来。

 为什么不直接生成目标代码？增加编译器的开发扩展性；便于对代码优化，中间代码的优化要比直接在目标代码优化难度低得多。
</code></pre>
</li>
<li>
<p>IR优化</p>
<pre><code> 各种优化：
 去除冗余代码
 优化循环、算术表达式等
</code></pre>
</li>
<li>
<p>目标代码生成</p>
<pre><code> 编译器根据中间代码和目标机器架构生成目标代码。
</code></pre>
</li>
<li>
<p>目标代码优化</p>
<pre><code> 利用目标机器的提供的特性对目标代码做进一步的优化，如利用 CPU 的流水线，利用 CPU 的多核等，生成最终的目标代码
</code></pre>
</li>
</ol>
<hr>
<p>参考：http://pandolia.net/tinyc/ch6_compiler_overview.html</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>【cs基础】如何判断算法的好坏</title>
      <link>https://justinbetter.github.io/2017/04/01/cs%E5%9F%BA%E7%A1%80%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F/</link>
      <pubDate>Sat, 01 Apr 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2017/04/01/cs%E5%9F%BA%E7%A1%80%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F/</guid>
      <description>&lt;p&gt;@[toc]
#算法复杂度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;平时我们说算法的好坏，排除一些软件和硬件上的限制，怎么去衡量这个算法运行的更快呢？这就是Big O notation的作用啦！
##Big O notation&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>@[toc]
#算法复杂度</p>
<ul>
<li>
<p>平时我们说算法的好坏，排除一些软件和硬件上的限制，怎么去衡量这个算法运行的更快呢？这就是Big O notation的作用啦！
##Big O notation</p>
</li>
<li>
<p>Big O notation是一种描述述函数渐进行为的理论，说白了，表达算法的增长趋势，一个算法会渐渐走向快速还是缓慢的表达方式。</p>
</li>
<li>
<p>这种渐进表达有三种记号来表示：O、 Θ 和 Ω 记号法。Θ 记号渐进地给出了一个函数的上界和下界，当只有渐近上界时使用 O 记号，当只有渐近下界时使用 Ω 记号。</p>
</li>
<li>
<p>譬如：</p>
<p>$T(n)=4n^2+2n+2$</p>
<p>当 n 增大到非常大时，$n^2$ 项将开始占主导地位 , 一般就用$O(n^2)$表示该算法的上界表示算法复杂度。</p>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDAxMTUxNTExMzM2?x-oss-process=image/format,png" alt="算法复杂度趋势一览"></p>
<hr>
<p>##算法的衡量从两个方向出发：时间复杂度和空间复杂度
###1. 时间复杂度</p>
<ul>
<li>算法完成其执行所需的总时间量</li>
<li>但是！算法执行的时间我们很难真实的估计，只能比较算法语句的执行次数，以此比较时间复杂度</li>
</ul>
<p>###2. 空间复杂度</p>
<ul>
<li>算法完成其执行所需的计算机存储器的总量</li>
<li>说白了，就是程序执行所需要的内存空间：
<ol>
<li>指令空间：用于存储已编译版本指令的内存量。</li>
<li>环境堆栈：在函数调用时存储部分执行函数信息的内存量。</li>
<li>数据空间：用于存储所有变量和常量的内存量。
##怎么做</li>
</ol>
</li>
<li>书读百遍，其义自见。</li>
</ul>
<hr>
<p>参考：
<a href="http://www.cnblogs.com/gaochundong/p/complexity_of_algorithms.html">http://www.cnblogs.com/gaochundong/p/complexity_of_algorithms.html</a>
<a href="http://www.ehcoo.com/complexity.html">http://www.ehcoo.com/complexity.html</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>【cs基础】浮点数的存储</title>
      <link>https://justinbetter.github.io/2017/03/29/cs%E5%9F%BA%E7%A1%80%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8/</link>
      <pubDate>Wed, 29 Mar 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2017/03/29/cs%E5%9F%BA%E7%A1%80%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8/</guid>
      <description>&lt;p&gt;#浮点数的存储
##为什么讨论浮点数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算机只能识别二进制，整数转化为二进制没有任何问题。&lt;/li&gt;
&lt;li&gt;但是！浮点数有小数点, 计算机怎么识别！必然要有个规范来规定计算机怎么识别吧！这个规范就是国际标准IEEE 754.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##浮点数的识别规范&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>#浮点数的存储
##为什么讨论浮点数</p>
<ul>
<li>计算机只能识别二进制，整数转化为二进制没有任何问题。</li>
<li>但是！浮点数有小数点, 计算机怎么识别！必然要有个规范来规定计算机怎么识别吧！这个规范就是国际标准IEEE 754.</li>
</ul>
<p>##浮点数的识别规范</p>
<ul>
<li>
<p>标准规定，任何浮点数的表现形式为</p>
<ul>
<li>V= （-1）^S x M x 2^E</li>
<li>符号位S</li>
<li>尾数位M</li>
<li>指数位E</li>
</ul>
</li>
<li>
<p>32bit : 符号位1，指数位8，尾数位23</p>
</li>
<li>
<p>64bit : 符号位1，指数位11，尾数位52</p>
</li>
<li>
<p>尾数位 M 默认总是1.xxx的形式，秉着优化的概念，标准规定保存的时候可以舍弃，读取的时候再加上，这样尾数范围也增加了 1 位</p>
</li>
<li>
<p>指数位2^E , E为8，指数范围0<del>255; E为11，指数范围 0</del>2047</p>
</li>
<li>
<p>但是！指数E可能为负数 也就是说指数范围可能为-127-128了，为了不出现负数，标准规定采用移位存储，保存的E数据就要+127或者+1023；</p>
</li>
<li>
<p>比如E = 10，必须保存成10+127=137，即10001001</p>
</li>
</ul>
<blockquote>
<p>（1）E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。
（2）E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。
（3）E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。</p>
</blockquote>
<p>##单精度和双精度误差</p>
<ul>
<li>十进制转化为二进制的时候，要是永远除不尽，单精度转换为双精度的时候，位数变少，多余的值被省忽略了，就会产生误差的问题</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>【cs基础】CPU是怎样执行代码的</title>
      <link>https://justinbetter.github.io/2017/03/17/cs%E5%9F%BA%E7%A1%80cpu%E6%98%AF%E6%80%8E%E6%A0%B7%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84/</link>
      <pubDate>Fri, 17 Mar 2017 20:00:22 +0800</pubDate>
      
      <guid>https://justinbetter.github.io/2017/03/17/cs%E5%9F%BA%E7%A1%80cpu%E6%98%AF%E6%80%8E%E6%A0%B7%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84/</guid>
      <description>&lt;p&gt;##基础概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序是指令和数据的组合体，被复制到内存才能运行。&lt;/li&gt;
&lt;li&gt;内存地址是保存指令和数据的场所，通过&lt;strong&gt;地址标记&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;CPU 能识别和执行的只有机器语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##CPU 结构
CPU 内部由寄存器、控制器、运算器和时钟四个部分构成，由电流信号相互连通&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>##基础概念</p>
<ul>
<li>程序是指令和数据的组合体，被复制到内存才能运行。</li>
<li>内存地址是保存指令和数据的场所，通过<strong>地址标记</strong>。</li>
<li>CPU 能识别和执行的只有机器语言。</li>
</ul>
<p>##CPU 结构
CPU 内部由寄存器、控制器、运算器和时钟四个部分构成，由电流信号相互连通</p>
<ul>
<li>寄存器： 保存指令、数据</li>
<li>控制器： 读取内存输入寄存器，控制指令流转</li>
<li>运算器： 运算寄存器中的数据</li>
<li>时钟：发出计时信号，代表运算速度</li>
</ul>
<p>##寄存器
程序是把寄存器作为对象来描述的，程序运行就是依赖寄存器的控制。</p>
<ul>
<li>存储的内容既可以是指令也可以是数据</li>
<li>数据分为“用于运算的数值”和“表示内存地址的数值”两种。数据种类不同，存储该数值的寄存器也不同</li>
</ul>
<blockquote>
<p>累加寄存器 &ndash;&gt; 运算的数值
基址寄存器和变址寄存器 &ndash;&gt; 表示内存地址的数值
标志寄存器 &ndash;&gt; 运算处理后的CPU的状态
程序计数器 &ndash;&gt; 下一条指令所在内存的地址
栈寄存器 &ndash;&gt; 栈区域的起始地址</p>
</blockquote>
<p>##程序函数的处理</p>
<ul>
<li>机器语言的 call 指令和 return 指令能够解决这个问题。函数调用使用的是 call 指令，而不是跳转指令。在将函数的入口地址设定到程序计数器之前，call 指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行 return 命令。return 命令的功能是把保存在栈中的地址设定到程序计数器中</li>
</ul>
<p>##CPU 处理
CPU 能执行的主要机器语言指令</p>
<blockquote>
</blockquote>
<ul>
<li>数据转送指令 &ndash;&gt; 寄存器和内存、内存和内存、寄存器和外围设备之间的数据读写操作</li>
<li>运算指令 &ndash;&gt; 用累加寄存器执行算术运算、逻辑运算、比较运算和移位运算</li>
<li>跳转指令 &ndash;&gt; 实现条件分支、循环、强制跳转等</li>
<li>call/return指令 &ndash;&gt; 函数的调用/返回调用前的地址</li>
</ul>
<p>参考：
《程序是怎样跑起来的》一书
<a href="http://cs.hnjk.net/T24Courses/2411/main/page/c040200.html">http://cs.hnjk.net/T24Courses/2411/main/page/c040200.html</a></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>